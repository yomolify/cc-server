'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports['default'] = write_assets;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _helpers = require('../helpers');

// writes webpack-assets.json file, which contains assets' file paths

function write_assets(json, options, log) {
	// take the passed in options
	options = (0, _helpers.clone)(options);

	// make webpack stats accessible for asset functions (parser, naming, filter)
	options.webpack_stats = json;

	log.debug('running write assets webpack plugin');

	var development = options.development;

	if (development) {
		log.debug(' (development mode is on)');
	}

	// create all the folders in the path if they don't exist
	_mkdirp2['default'].sync(_path2['default'].dirname(options.webpack_assets_path));

	// in debug mode, write webpack stats json for debugging purpose
	if (options.debug) {
		var webpack_stats_file_path = _path2['default'].resolve(_path2['default'].dirname(options.webpack_assets_path), 'webpack-stats.debug.json');

		// write webpack stats file
		log.debug('writing webpack stats to ' + webpack_stats_file_path);
		// write the file (format the JSON for readability)
		_fs2['default'].writeFileSync(webpack_stats_file_path, JSON.stringify(json, null, 2));
	}

	// the output object with assets
	var output = options.output;

	// populate the output object with assets
	populate_assets(output, json, options, log);

	// write webpack assets info file
	log.debug('writing webpack assets info to ' + options.webpack_assets_path);
	// format the JSON for readability if in debug mode
	var assets_info = development ? JSON.stringify(output, null, 2) : JSON.stringify(output);
	// write the file
	_fs2['default'].writeFileSync(options.webpack_assets_path, assets_info);
}

// populates the output object with assets
function populate_assets(output, json, options, log) {
	// for each chunk name ("main", "common", ...)
	_Object$keys(json.assetsByChunkName).forEach(function (name) {
		log.debug('getting javascript and styles for chunk "' + name + '"');

		// get javascript chunk real file path

		var javascript = get_assets(name, 'js')[0];
		// the second asset is usually a source map

		if (javascript) {
			log.debug(' (got javascript)');
			output.javascript[name] = javascript;
		}

		// get style chunk real file path

		var style = get_assets(name, 'css')[0];
		// the second asset is usually a source map

		if (style) {
			log.debug(' (got style)');
			output.styles[name] = style;
		}
	});

	// gets asset paths by name and extension of their chunk
	function get_assets(name) {
		var extension = arguments.length <= 1 || arguments[1] === undefined ? 'js' : arguments[1];

		var chunk = json.assetsByChunkName[name];

		// a chunk could be a string or an array, so make sure it is an array
		if (!Array.isArray(chunk)) {
			chunk = [chunk];
		}

		return chunk
		// filter by extension
		.filter(function (name) {
			return _path2['default'].extname(name) === '.' + extension;
		})
		// adjust the real path (can be http, filesystem)
		.map(function (name) {
			return options.assets_base_path + name;
		});
	}

	// // output assets for all application javascript entry points
	// Object.keys(this.options.entry).forEach(chunk_name =>
	// {
	// 	let entry = this.options.entry[chunk_name]
	// 	if (Array.isArray(entry))
	// 	{
	// 		entry = entry[entry.length - 1]
	// 	}
	//
	// 	output.javascript[entry] = get_assets(chunk_name, 'js')[0]
	// 	// the second asset is usually a source map
	// })

	// // omit node_modules contents and internal webpack modules
	// const modules = json.modules.filter(module =>
	// {
	// 	return module.name.indexOf('.') === 0 && module.name.indexOf('./~/') !== 0
	// 	// return module.name.indexOf('./~/') !== 0 && module.name.indexOf('(webpack)') !== 0
	// })

	// one can supply a custom filter
	var default_filter = function default_filter(module, regular_expression) {
		return regular_expression.test(module.name);
	};
	// one can supply a custom namer
	var default_naming = function default_naming(module) {
		return module.name;
	};

	// for each user specified asset type
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		var _loop = function () {
			var asset_type = _step.value;

			var asset_description = options.assets[asset_type];

			// one can supply his own filter
			var filter = asset_description.filter || default_filter; //.bind(this)
			// one can supply his own parser
			var parser = asset_description.parser; //.bind(this)
			// one can supply his own namer
			var naming = asset_description.naming || default_naming; //.bind(this)

			// parser is required
			if (!asset_description.parser) {
				throw new Error('"parser" function is required for assets type "' + asset_type + '". See the Configuration section of the README for explanation.');
			}

			log.debug('populating assets of type "' + asset_type + '"');

			// timer start
			var began_at = new Date().getTime();

			// initialization
			output[asset_type] = output[asset_type] || {};

			// get real paths for all the files from this asset type
			json.modules
			// take just modules of this asset type
			.filter(function (module) {
				return filter(module, options.regular_expressions[asset_type], options, log);
			}).reduce(function (set, module) {
				// determine asset name
				var name = naming(module, options, log);
				// determine and set the real file path for the asset
				set[name] = parser(module, options, log); // || ''
				// continue
				return set;
			}, output[asset_type]);

			// timer stop
			log.debug(' time taken: ' + (new Date().getTime() - began_at) + ' ms');
		};

		for (var _iterator = _getIterator(_Object$keys(options.assets)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			_loop();
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator['return']) {
				_iterator['return']();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}
}
module.exports = exports['default'];
//# sourceMappingURL=write assets.js.map