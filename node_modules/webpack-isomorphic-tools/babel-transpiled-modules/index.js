'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _path2 = require('path');

var _path3 = _interopRequireDefault(_path2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _toolsNodeHook = require('./tools/node-hook');

var _toolsNodeHook2 = _interopRequireDefault(_toolsNodeHook);

var _toolsSerializeJavascript = require('./tools/serialize-javascript');

var _toolsSerializeJavascript2 = _interopRequireDefault(_toolsSerializeJavascript);

var _toolsLog = require('./tools/log');

var _toolsLog2 = _interopRequireDefault(_toolsLog);

var _helpers = require('./helpers');

var _common = require('./common');

// using ES6 template strings
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings

var webpack_isomorphic_tools = (function () {
	function webpack_isomorphic_tools(options) {
		_classCallCheck(this, webpack_isomorphic_tools);

		// take the passed in options
		this.options = (0, _helpers.alias_camel_case)((0, _helpers.clone)(options));

		// a list of files which can be require()d normally on the server
		// (for example, if you have require("./file.json") both in webpack and in the server code)
		// (should work, not tested)
		this.options.exceptions = this.options.exceptions || [];

		// used to keep track of cached assets and flush their caches on .refresh() call
		this.cached_assets = [];

		// add missing fields, etc
		(0, _common.normalize_options)(this.options);

		// logging
		this.log = new _toolsLog2['default']('webpack-isomorphic-tools', { debug: this.options.debug });

		this.log.debug('instantiated webpack-isomorphic-tools with options', this.options);
	}

	_createClass(webpack_isomorphic_tools, [{
		key: 'development',

		// sets development mode flag to whatever was passed (or true if nothing was passed)
		// (development mode allows asset hot reloading when used with webpack-dev-server)
		value: function development(flag) {
			// set development mode flag
			this.options.development = (0, _helpers.exists)(flag) ? flag : true;

			if (this.options.development) {
				this.log.debug('entering development mode');
			} else {
				this.log.debug('entering production mode');
			}

			// allows method chaining
			return this;
		}
	}, {
		key: 'assets',

		// returns a mapping to read file paths for all the user specified asset types
		// along with a couple of predefined ones: javascripts and styles
		value: function assets() {
			// webpack and node.js start in parallel
			// so webpack-assets.json might not exist on the very first run
			// (or there should be a better way of webpack notifying about build ending)
			if (!_fs2['default'].existsSync(this.webpack_assets_path)) {
				this.log.error('"' + this.webpack_assets_path + '" not found. Using an empty stub instead');
				return (0, _common.default_webpack_assets)();
			}

			return require(this.webpack_assets_path);
		}
	}, {
		key: 'refresh',

		// clear the require.cache (only used in developer mode with webpack-dev-server)
		value: function refresh() {
			// ensure this is development mode
			if (!this.options.development) {
				throw new Error('.refresh() called in production mode. Did you forget to call .development() method on your webpack-isomorphic-tools server instance?');
			}

			this.log.debug('flushing require() caches');

			// uncache webpack-assets.json file
			// this.log.debug(' flushing require() cache for webpack assets json file')
			// this.log.debug(` (was cached: ${typeof(require.cache[this.webpack_assets_path]) !== 'undefined'})`)
			delete require.cache[this.webpack_assets_path];

			// uncache cached assets
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = _getIterator(this.cached_assets), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _path = _step.value;

					this.log.debug(' flushing require() cache for ' + _path);
					delete require.cache[_path];
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator['return']) {
						_iterator['return']();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			// no assets are cached now
			this.cached_assets = [];
		}
	}, {
		key: 'server',

		// Initializes server-side instance of `webpack-isomorphic-tools`
		// with the base path for your project, then calls `.register()`,
		// and after that calls .ready(callback).
		//
		// The `project_path` parameter must be identical
		// to the `context` parameter of your Webpack configuration
		// and is needed to locate `webpack-assets.json`
		//  which is output by Webpack process.
		//
		// sets up "project_path" option
		// (this option is required on the server to locate webpack-assets.json)
		value: function server(project_path, callback) {
			// project base path, required to locate webpack-assets.json
			this.options.project_path = project_path;

			// resolve webpack-assets.json file path
			this.webpack_assets_path = _path3['default'].resolve(this.options.project_path, this.options.webpack_assets_file_path);

			// register require() hooks
			this.register();

			// call back when ready
			return this.ready(callback);
		}
	}, {
		key: 'register',

		// Registers Node.js require() hooks for the assets
		//
		// This is what makes the `requre()` magic work on server.
		// These `require()` hooks must be set before you `require()`
		// any of your assets
		// (e.g. before you `require()` any React components
		// `require()`ing your assets).
		//
		// read this article if you don't know what a "require hook" is
		// http://bahmutov.calepin.co/hooking-into-node-loader-for-fun-and-profit.html
		value: function register() {
			var _this = this;

			this.log.debug('registering require() hooks for assets');

			// for each user specified asset type which isn't for .js files
			// (because '.js' files requiring already works natively)
			_Object$keys(this.options.assets).filter(function (asset_type) {
				var description = _this.options.assets[asset_type];

				if (description.extension) {
					return description.extension !== 'js';
				} else {
					return description.extensions.indexOf('js') < 0;
				}
			})
			// register a require hook for each file extension of this asset type
			.forEach(function (asset_type) {
				var description = _this.options.assets[asset_type];

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = _getIterator(description.extensions), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var extension = _step2.value;

						_this.register_extension(extension);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2['return']) {
							_iterator2['return']();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			});

			// allows method chaining
			return this;
		}
	}, {
		key: 'require',

		// is called when you require() your assets
		// (or can be used manually without require hooks)
		value: function require(asset_path) {
			this.log.debug('requiring ' + asset_path);

			// sanity check
			if (!asset_path) {
				// return ''
				return undefined;
			}

			// get real file path list
			var assets = this.assets();

			// find this asset in the real file path list
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = _getIterator(_Object$keys(assets)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var type = _step3.value;

					var asset = assets[type][asset_path];
					// if the real path was found in the list - return it
					if ((0, _helpers.exists)(asset)) {
						return asset;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3['return']) {
						_iterator3['return']();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			// serve a not-found asset maybe
			this.log.error('asset not found: ' + asset_path);
			// return ''
			return undefined;
		}
	}, {
		key: 'register_extension',

		// registers a require hook for a particular file extension
		value: function register_extension(extension) {
			var _this2 = this;

			this.log.debug(' registering a require() hook for *.' + extension);

			// place the require() hook for this extension
			_toolsNodeHook2['default'].hook('.' + extension, function (asset_path, fallback) {
				_this2.log.debug('require() hook fired for ' + asset_path);

				// for caching
				var global_asset_path = asset_path;

				// sanity check
				if (!_this2.options.project_path) {
					throw new Error('You forgot to call the .server() method passing it your project\'s base path');
				}

				// convert absolute path to relative path
				asset_path = _path3['default'].relative(_this2.options.project_path, asset_path);

				// convert Windows path to a correct Webpack path
				asset_path = asset_path.replace(/\\/g, '/');
				// add './' in the beginning if it's missing (is the case on Windows for example)
				if (asset_path.indexOf('.') !== 0) {
					asset_path = './' + asset_path;
				}

				// if this filename is in the user specified exceptions list
				// then fallback to the normal require() behaviour
				if (_this2.options.exceptions.indexOf(asset_path) >= 0) {
					_this2.log.debug('skipping require call for ' + asset_path);
					return fallback();
				}

				// track cached assets (only in development mode)
				if (_this2.options.development) {
					// mark this asset as cached
					_this2.cached_assets.push(global_asset_path);
				}

				// require() this asset (returns the real file path for this asset, e.g. an image)
				return _this2.require(asset_path);
			});
		}
	}, {
		key: 'ready',

		// Waits for webpack-assets.json to be created after Webpack build process finishes
		//
		// The callback is called when `webpack-assets.json` has been found
		// (it's needed for development because `webpack-dev-server`
		//  and your application server are usually run in parallel).
		//
		value: function ready(done) {
			var _this3 = this;

			// condition check interval
			var interval = 1000; // in milliseconds

			// selfie
			var tools = this;

			// waits for condition to be met, then proceeds
			function wait_for(condition, proceed) {
				function check() {
					// if the condition is met, then proceed
					if (condition()) {
						return proceed();
					}

					tools.log.debug('(' + tools.webpack_assets_path + ' not found)');
					tools.log.info('(waiting for the first Webpack build to finish)');

					setTimeout(check, interval);
				}

				check();
			}

			// wait for webpack-assets.json to be written to disk by Webpack
			wait_for(function () {
				return _fs2['default'].existsSync(_this3.webpack_assets_path);
			}, done);

			// allows method chaining
			return this;
		}
	}]);

	return webpack_isomorphic_tools;
})();

exports['default'] = webpack_isomorphic_tools;
module.exports = exports['default'];
//# sourceMappingURL=index.js.map