'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utilsInjectStyle = require('../utils/inject-style');

var _utilsUnionClassNames = require('../utils/union-class-names');

var _utilsUnionClassNames2 = _interopRequireDefault(_utilsUnionClassNames);

var _utilsHelpers = require('../utils/helpers');

var _utilsDateHelpers = require('../utils/date-helpers');

var _styleDatePicker = require('../style/date-picker');

var _styleDatePicker2 = _interopRequireDefault(_styleDatePicker);

var _configDatePicker = require('../config/datePicker');

var _configDatePicker2 = _interopRequireDefault(_configDatePicker);

// Enable React Touch Events
_react2['default'].initializeTouchEvents(true);

/**
 * DatePicker React Component.
 */

var DatePicker = (function (_Component) {
  function DatePicker(properties) {
    _classCallCheck(this, DatePicker);

    _get(Object.getPrototypeOf(DatePicker.prototype), 'constructor', this).call(this, properties);
    var dateValue = undefined;

    if ((0, _utilsHelpers.has)(properties, 'valueLink')) {
      dateValue = properties.valueLink.value;
    } else if ((0, _utilsHelpers.has)(properties, 'value')) {
      dateValue = properties.value;
    } else if ((0, _utilsHelpers.has)(properties, 'defaultValue')) {
      dateValue = properties.defaultValue;
    }

    this.state = {
      dateValue: dateValue,
      month: properties.month - 1,
      year: properties.year,
      localeData: (0, _utilsDateHelpers.getLocaleData)(properties.locale)
    };

    this.preventFocusStyleForTouchAndClick = (0, _utilsHelpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _configDatePicker2['default'].preventFocusStyleForTouchAndClick;
  }

  _inherits(DatePicker, _Component);

  _createClass(DatePicker, [{
    key: 'componentWillMount',

    /**
     * Generates the style-id based on React's unique DOM node id.
     * Calls function to inject the pseudo classes into the dom.
     */
    value: function componentWillMount() {
      var id = this._reactInternalInstance._rootNodeID.replace(/\./g, '-');
      this.pseudoStyleIds = {};
      this.pseudoStyleIds.wrapperStyleId = 'wrapper-style-id' + id;
      this.pseudoStyleIds.navBarStyleId = 'navBar-style-id' + id;
      this.pseudoStyleIds.prevMonthStyleId = 'prevMonth-style-id' + id;
      this.pseudoStyleIds.nextMonthStyleId = 'nextMonth-style-id' + id;
      this.pseudoStyleIds.monthLblStyleId = 'monthLbl-style-id' + id;
      this.pseudoStyleIds.dayLblStyleId = 'dayLbl-style-id' + id;
      this.pseudoStyleIds.dayStyleId = 'day-style-id' + id;
      DatePicker.updatePseudoClassStyle(this.pseudoStyleIds, this.props, this.preventFocusStyleForTouchAndClick);
    }
  }, {
    key: 'componentWillReceiveProps',

    /**
     * FUnction will update component state and styles as new props are received.
     */
    value: function componentWillReceiveProps(properties) {

      var newState = {
        month: properties.month - 1,
        year: properties.year,
        localeData: (0, _utilsDateHelpers.getLocaleData)(properties.locale)
      };

      if ((0, _utilsHelpers.has)(properties, 'valueLink')) {
        newState.dateValue = properties.valueLink.value;
      } else if ((0, _utilsHelpers.has)(properties, 'value')) {
        newState.dateValue = properties.value;
      }

      this.setState(newState);
      this.preventFocusStyleForTouchAndClick = (0, _utilsHelpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _configDatePicker2['default'].preventFocusStyleForTouchAndClick;

      (0, _utilsInjectStyle.removeAllStyles)(Object.keys(this.pseudoStyleIds));
      DatePicker.updatePseudoClassStyle(this.pseudoStyleIds, properties, this.preventFocusStyleForTouchAndClick);
    }
  }, {
    key: 'componentWillUnmount',

    /**
     * Removes pseudo classes from the DOM once component gets removed.
     */
    value: function componentWillUnmount() {
      (0, _utilsInjectStyle.removeAllStyles)(Object.keys(this.pseudoStyleIds));
    }
  }, {
    key: '_onWrapperFocus',

    /**
     * Callback is called when wrapper is focused.
     * It will conditionally set isWrapperFocused and call props.onFocus.
     */
    value: function _onWrapperFocus(event) {
      if (!this.props.disabled && !this.state.isWrapperActive) {
        this.setState({
          isWrapperFocused: true
        });
      }

      if (this.props.onFocus) {
        this.props.onFocus(event);
      }
    }
  }, {
    key: '_onWrapperBlur',

    /**
     * Callback is called when wrapper is blurred.
     * It will reset isWrapperFocused and call props.onBlur.
     */
    value: function _onWrapperBlur(event) {
      if (!this.props.disabled) {
        this.setState({
          isWrapperFocused: false
        });
      }

      if (this.props.onBlur) {
        this.props.onBlur(event);
      }
    }
  }, {
    key: '_onWrapperMouseDown',

    /**
     * Callback is called when wrapper receives mouseDown.
     * Conditionally set isWrapperActive.
     */
    value: function _onWrapperMouseDown(event) {
      if (!this.props.disabled && event.button === 0) {
        this.setState({
          isWrapperActive: true
        });
      }
    }
  }, {
    key: '_onWrapperMouseUp',

    /**
     * Callback is called when wrapper receives mouseUp.
     * Reset isWrapperActive.
     */
    value: function _onWrapperMouseUp(event) {
      if (!this.props.disabled && event.button === 0) {
        this.setState({
          isWrapperActive: false
        });
      }
    }
  }, {
    key: '_onWrapperMouseOver',

    /**
     * Callback is called when mouse enters wrapper.
     * Conditionally set isWrapperHovered.
     */
    value: function _onWrapperMouseOver() {
      this.setState({
        isWrapperHovered: true
      });
    }
  }, {
    key: '_onWrapperMouseOut',

    /**
     * Callback is called when mouse leaves wrapper.
     * Reset isWrapperHovered.
     */
    value: function _onWrapperMouseOut() {
      this.setState({
        isWrapperHovered: false
      });
    }
  }, {
    key: '_onWrapperTouchStart',

    /**
     * Callback is called when touch starts on wrapper.
     * Conditionally sets isWrapperActive.
     */
    value: function _onWrapperTouchStart(event) {
      if (!this.props.disabled && event.touches.length === 1) {
        this.setState({
          isWrapperActive: true
        });
      }
    }
  }, {
    key: '_onWrapperTouchEnd',

    /**
     * Callback is called when touch ends on wrapper.
     * Reset isWrapperActive.
     */
    value: function _onWrapperTouchEnd() {
      if (!this.props.disabled) {
        this.setState({
          isWrapperActive: false
        });
      }
    }
  }, {
    key: '_onWrapperKeyDown',

    /**
     * The callback is called when wrapper receives keyDown event.
     * 1. If wrapper is focused: ArrowLeft/ ArrowRight keys will increase or decrease month.
     * 2. If previousMonth if focused: Enter key will decrease month.
     * 3. If nextMonth is focused: Enter key will increase the month.
     * 4. Id some day is focused: arrow keys will navigate calendar and enter key will change dateValue of component.
     * Function will call props.onDayKeyDown or props.onKeyDown depending on whether wrapper or day is focused.
     */
    value: function _onWrapperKeyDown(event) {
      if (!this.props.disabled) {
        if (event.key === 'ArrowDown') {
          event.preventDefault();
          if (this.state.focusedDay) {
            this._focusNextDay(7);
          }
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          if (this.state.focusedDay) {
            this._focusPreviousDay(7);
          }
        } else if (event.key === 'ArrowLeft') {
          event.preventDefault();
          if (this.state.focusedDay) {
            this._focusPreviousDay(1);
          } else if (this.state.isWrapperFocused) {
            this._decreaseMonth();
          }
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          if (this.state.focusedDay) {
            this._focusNextDay(1);
          } else if (this.state.isWrapperFocused) {
            this._increaseMonth();
          }
        } else if (event.key === 'Enter') {
          event.preventDefault();
          if (this.state.focusedDay) {
            this._selectDate(new Date(this.state.focusedDay).getDate());
          } else if (this.state.isPrevMonthFocused) {
            this._decreaseMonth();
          } else if (this.state.isNextMonthFocused) {
            this._increaseMonth();
          }
        }
      }

      if (this.state.focusedDay && this.props.onDayKeyDown) {
        this.props.onDayKeyDown(event);
      }if (this.props.onKeyDown) {
        this.props.onKeyDown(event);
      }
    }
  }, {
    key: '_onDayFocus',

    /**
     * Callback is called when some day received focus.
     * It will conditionally set this.state.focusedDay to value of focused day and call props.onDayFocus.
     */
    value: function _onDayFocus(dayKey, event) {
      if (!this.props.disabled && !this.props.readOnly) {
        this.setState({
          focusedDay: dayKey
        });
      }

      if (this.props.onDayFocus) {
        this.props.onDayFocus(event);
      }
    }
  }, {
    key: '_onDayBlur',

    /**
     * Callback is called when some day receives blur.
     * It will reset this.state.focusedDay and call props.onDayBlur.
     */
    value: function _onDayBlur(dayKey, event) {
      if (!this.props.disabled && this.state.focusedDay && this.state.focusedDay === dayKey) {
        this.setState({
          focusedDay: null
        });
      }

      if (this.props.onDayBlur) {
        this.props.onDayBlur(event);
      }
    }
  }, {
    key: '_onDayMouseDown',

    // mouseEvent.button is supported by all browsers are are targeting: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
    /**
     * Callback is called when some day receives mouseDown.
     * It will conditionally set this.state.activeDay and call props.onDayMouseDown.
     */
    value: function _onDayMouseDown(dayKey, day, event) {
      if (event.button === 0 && !this.props.disabled && !this.props.readOnly) {
        this._selectDate(day);
        this.setState({
          activeDay: dayKey
        });
      }

      if (this.props.onDayMouseDown) {
        this.props.onDayMouseDown(event);
      }
    }
  }, {
    key: '_onDayMouseUp',

    /**
     * Callback is called when some day receives mouseUp.
     * It will reset this.state.activeDay and call props.onDayMouseUp.
     */
    value: function _onDayMouseUp(dayKey, event) {
      if (event.button === 0 && !this.props.disabled && !this.props.readOnly && this.state.activeDay === dayKey) {
        this.setState({
          activeDay: null
        });
      }

      if (this.props.onDayMouseUp) {
        this.props.onDayMouseUp(event);
      }
    }
  }, {
    key: '_onDayMouseOver',

    /**
     * Callback is called when some day receives MouseOver.
     * It will conditionally set this.state.hoveredDay.
     */
    value: function _onDayMouseOver(dayKey) {
      if (!this.props.disabled && !this.props.readOnly) {
        this.setState({
          hoveredDay: dayKey
        });
      }
    }
  }, {
    key: '_onDayMouseOut',

    /**
     * Callback is called when some day receives MouseOut.
     * It will reset this.state.hoveredDay.
     */
    value: function _onDayMouseOut(dayKey, event) {
      if (!this.props.disabled && !this.props.readOnly && event.button === 0 && this.state.hoveredDay === dayKey) {
        this.setState({
          hoveredDay: 0
        });
      }
    }
  }, {
    key: '_onDayTouchStart',

    /**
     * Callback is called when some day receives touchStart.
     * It will conditionally set this.state.activeDay and call props.onDayTouchStart.
     */
    value: function _onDayTouchStart(dayKey, day, event) {
      if (!this.props.disabled && !this.props.readOnly && event.touches.length === 1) {
        this._selectDate(day);
        this.setState({
          activeDay: dayKey
        });
      }

      if (this.props.onDayTouchStart) {
        this.props.onDayTouchStart(event);
      }
    }
  }, {
    key: '_onDayTouchEnd',

    /**
     * Callback is called when some day receives touchEnd.
     * It will reset this.state.activeDay and call props.onDayTouchEnd.
     */
    value: function _onDayTouchEnd(dayKey, event) {
      if (!this.props.disabled && !this.props.readOnly && event.touches.length === 1 && this.state.activeDay === dayKey) {
        this.setState({
          activeDay: null
        });
      }

      if (this.props.onDayTouchEnd) {
        this.props.onDayTouchEnd(event);
      }
    }
  }, {
    key: '_selectDate',

    /**
     * Depending on whether component is controlled or uncontrolled the function will update this.state.dateValue.constructor.
     * It will also call props.onUpdate.
     */
    value: function _selectDate(date) {
      if (!this.props.disabled && !this.props.readOnly) {
        var dateValue = new Date(this.state.year, this.state.month, date);
        if ((0, _utilsHelpers.has)(this.props, 'valueLink')) {
          this.props.valueLink.requestChange(dateValue);
        } else if (!(0, _utilsHelpers.has)(this.props, 'value')) {
          this.setState({
            dateValue: dateValue
          });
        }

        if (this.props.onUpdate) {
          this.props.onUpdate({
            value: dateValue
          });
        }
      }
    }
  }, {
    key: '_getNavBar',

    /**
     * Function will return jsx for rendering the nav bar for calendar.
     * Depending on following rules it will apply various styles:
     * 1. If component is readOnly apply readOnly styles
     * 2. If component is disabled apply disabled styles
     * 3. If component is not disabled
     *    - If its active apply activeStyles
     *    - If its not active and is focused also preventFocusStyleForTouchAndClick is true apply focus styles
     * (If preventFocusStyleForTouchAndClick is false focus styles already get applied by pseudo classes).
     */
    value: function _getNavBar() {
      var navBarStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].navBarStyle, this.props.navBarStyle);
      var prevMonthStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].prevMonthStyle, this.props.prevMonthStyle);
      var nextMonthStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].nextMonthStyle, this.props.nextMonthStyle);
      var monthLblStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].monthLblStyle, this.props.monthLblStyle);
      if (this.props.readOnly) {
        navBarStyle = (0, _utilsHelpers.extend)(navBarStyle, _styleDatePicker2['default'].readOnlyNavBarStyle, this.props.readOnlyNavBarStyle);
        prevMonthStyle = (0, _utilsHelpers.extend)(prevMonthStyle, _styleDatePicker2['default'].readOnlyPrevMonthStyle, this.props.readOnlyPrevMonthStyle);
        nextMonthStyle = (0, _utilsHelpers.extend)(nextMonthStyle, _styleDatePicker2['default'].readOnlyNextMonthStyle, this.props.readOnlyNextMonthStyle);
        monthLblStyle = (0, _utilsHelpers.extend)(monthLblStyle, _styleDatePicker2['default'].readOnlyMonthLblStyle, this.props.readOnlyMonthLblStyle);
      }
      if (this.props.disabled) {
        navBarStyle = (0, _utilsHelpers.extend)(navBarStyle, _styleDatePicker2['default'].disabledNavBarStyle, this.props.disabledNavBarStyle);
        prevMonthStyle = (0, _utilsHelpers.extend)(prevMonthStyle, _styleDatePicker2['default'].disabledPrevMonthStyle, this.props.disabledPrevMonthStyle);
        nextMonthStyle = (0, _utilsHelpers.extend)(nextMonthStyle, _styleDatePicker2['default'].disabledNextMonthStyle, this.props.disabledNextMonthStyle);
        monthLblStyle = (0, _utilsHelpers.extend)(monthLblStyle, _styleDatePicker2['default'].disabledMonthLblStyle, this.props.disabledMonthLblStyle);
      } else {
        if (this.state.isPrevMonthActive) {
          prevMonthStyle = (0, _utilsHelpers.extend)(prevMonthStyle, _styleDatePicker2['default'].activePrevMonthStyle, this.props.activePrevMonthStyle);
        } else if (this.preventFocusStyleForTouchAndClick && this.state.isPrevMonthFocused) {
          prevMonthStyle = (0, _utilsHelpers.extend)(prevMonthStyle, _styleDatePicker2['default'].focusPrevMonthStyle, this.props.focusPrevMonthStyle);
        }
        if (this.state.isNextMonthActive) {
          nextMonthStyle = (0, _utilsHelpers.extend)(nextMonthStyle, _styleDatePicker2['default'].activeNextMonthStyle, this.props.activeNextMonthStyle);
        } else if (this.preventFocusStyleForTouchAndClick && this.state.isNextMonthFocused) {
          nextMonthStyle = (0, _utilsHelpers.extend)(nextMonthStyle, _styleDatePicker2['default'].focusNextMonthStyle, this.props.focusNextMonthStyle);
        }
      }

      return _react2['default'].createElement(
        'div',
        { style: navBarStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.navBarClassName, this.pseudoStyleIds.navBarStyleId) },
        _react2['default'].createElement('span', { tabIndex: this.props.tabIndex,
          onMouseDown: this._onPrevMonthMouseDown.bind(this),
          onMouseUp: this._onPrevMonthMouseUp.bind(this),
          onTouchStart: this._onPrevMonthTouchStart.bind(this),
          onTouchEnd: this._onPrevMonthTouchEnd.bind(this),
          onFocus: this._onPrevMonthFocus.bind(this),
          onBlur: this._onPrevMonthBlur.bind(this),
          style: prevMonthStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.prevMonthClassName, this.pseudoStyleIds.prevMonthStyleId) }),
        _react2['default'].createElement(
          'span',
          { style: monthLblStyle,
            className: (0, _utilsUnionClassNames2['default'])(this.props.monthLblClassName, this.pseudoStyleIds.monthLblStyleId) },
          this.state.localeData.monthNames[this.state.month] + '-' + this.state.year
        ),
        _react2['default'].createElement('span', { tabIndex: this.props.tabIndex,
          onMouseDown: this._onNextMonthMouseDown.bind(this),
          onMouseUp: this._onNextMonthMouseUp.bind(this),
          onTouchStart: this._onNextMonthTouchStart.bind(this),
          onTouchEnd: this._onNextMonthTouchEnd.bind(this),
          onFocus: this._onNextMonthFocus.bind(this),
          onBlur: this._onNextMonthBlur.bind(this),
          style: nextMonthStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.nextMonthClassName, this.pseudoStyleIds.nextMonthStyleId) })
      );
    }
  }, {
    key: '_getDaysHeader',

    /**
     * Function will return jsx for rendering the week header for calendar.
     * Depending on following rules it will apply various styles:
     * 1. If component is readOnly apply readOnly styles
     * 2. If component is disabled apply disabled styles
     */
    value: function _getDaysHeader() {
      var _this = this;

      var dayLblStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].dayLblStyle, this.props.dayLblStyle);
      var weekHeaderStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].weekHeaderStyle, this.props.weekHeaderStyle);
      if (this.props.readOnly) {
        dayLblStyle = (0, _utilsHelpers.extend)(dayLblStyle, _styleDatePicker2['default'].readOnlyDayLblStyle, this.props.readOnlyDayLblStyle);
        weekHeaderStyle = (0, _utilsHelpers.extend)(weekHeaderStyle, _styleDatePicker2['default'].weekHeaderStyle, this.props.weekHeaderStyle);
      }
      if (this.props.disabled) {
        dayLblStyle = (0, _utilsHelpers.extend)(dayLblStyle, _styleDatePicker2['default'].disabledDayLblStyle, this.props.disabledDayLblStyle);
        weekHeaderStyle = (0, _utilsHelpers.extend)(weekHeaderStyle, _styleDatePicker2['default'].disabledWeekHeaderStyle, this.props.disabledWeekHeaderStyle);
      }
      var weekendLblStyle = (0, _utilsHelpers.extend)({}, dayLblStyle, _styleDatePicker2['default'].weekendLblStyle, this.props.weekendLblStyle);
      var dayNames = (0, _utilsHelpers.shift)(this.state.localeData.dayNamesMin, this.state.localeData.firstDay);
      dayNames = this.state.localeData.isRTL ? (0, _utilsHelpers.reverse)(dayNames) : dayNames;

      return _react2['default'].createElement(
        'div',
        { style: weekHeaderStyle },
        (0, _utilsHelpers.map)(dayNames, function (dayAbbr, index) {
          var weekendIndex = (7 - _this.state.localeData.firstDay) % 7 + _this.state.localeData.weekEnd;
          weekendIndex = _this.state.localeData.isRTL ? 6 - weekendIndex : weekendIndex;
          return _react2['default'].createElement(
            'span',
            { key: 'dayAbbr-' + index,
              style: _this.props.styleWeekend && index === weekendIndex ? weekendLblStyle : dayLblStyle,
              className: (0, _utilsUnionClassNames2['default'])(_this.props.dayLblClassName, _this.pseudoStyleIds.dayLblStyleId) },
            dayAbbr
          );
        })
      );
    }
  }, {
    key: '_getDayFragment',

    // According to http://www.w3.org/TR/wai-aria-1.1/#aria-current an empty value for aria-current indicated false.
    /**
     * Function will return jsx for rendering the a day.
     * It will apply various styles in sequence as below (styles will be additive):
     * 1. If component is readOnly apply readOnly styles
     * 2. If component is disabled apply disabled styles
     *    - If component is disabled and hovered apply diableHover styles
     * 3. If its day in current month and component is not disabled or readOnly:
     *    - If component is hovered apply hover styles
     *    - If component is hovered and active apply hoveredStyles + activeStyles
     *    - If component is hovered and not active but focused and preventFocusStyleForTouchAndClick apply focus styles
     * 4. If current day represents other months day in calendar apply otherMonthDayStyle
     * 5. If its current day apply todayStyle
     * 6. If this is selected day apply selectedDayStyle
     */
    value: function _getDayFragment(currentDate, index) {
      var day = currentDate.getDate();
      var isCurrentMonth = currentDate.getMonth() === this.state.month;
      var dayKey = currentDate.getMonth() + 1 + '/' + currentDate.getDate() + '/' + currentDate.getFullYear();

      var dateValue = this.state.dateValue;

      var ariaCurrent = '';
      var ariaSelected = false;

      var dayStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].dayStyle, this.props.dayStyle);

      if (this.props.readOnly) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].readOnlyDayStyle, this.props.readOnlyDayStyle);
      }

      if (this.props.disabled) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].disabledDayStyle, this.props.disabledDayStyle);
        if (isCurrentMonth && this.state.hoveredDay === dayKey) {
          dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].disabledHoverDayStyle, this.props.disabledHoverDayStyle);
        }
      }

      if (this.props.styleWeekend && currentDate.getDay() === this.state.localeData.weekEnd) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].weekendStyle, this.props.weekendStyle);
      }

      if (!isCurrentMonth) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].otherMonthDayStyle, this.props.otherMonthDayStyle);
      } else {
        if (isCurrentMonth && !this.props.readOnly && !this.props.disabled) {
          if (this.state.hoveredDay === dayKey) {
            dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].hoverDayStyle, this.props.hoverDayStyle);
          }
          if (this.state.activeDay === dayKey) {
            dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].activeDayStyle, this.props.activeDayStyle);
          }
        }
      }

      if (this.state.activeDay !== dayKey && dateValue && day === dateValue.getDate() && this.state.month === dateValue.getMonth() && dateValue.getMonth() === currentDate.getMonth() && this.state.year === dateValue.getFullYear()) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].selectedDayStyle, this.props.selectedDayStyle);
        ariaSelected = true;
      }

      if (day === _utilsDateHelpers.CURRENT_DATE && this.state.month === _utilsDateHelpers.CURRENT_MONTH && this.state.year === _utilsDateHelpers.CURRENT_YEAR) {
        dayStyle = (0, _utilsHelpers.extend)(dayStyle, _styleDatePicker2['default'].todayStyle, this.props.todayStyle);
        ariaCurrent = 'date';
      }

      // Setting tabIndex to false makes the div non-focuseable, its still focuseable with value of -1.
      var tabIndex = !this.props.disabled && !this.props.readOnly && isCurrentMonth ? this.props.tabIndex : false;
      return isCurrentMonth ? _react2['default'].createElement(
        'span',
        { tabIndex: tabIndex,
          key: 'day-' + index,
          ref: 'day-' + dayKey,
          onMouseDown: this._onDayMouseDown.bind(this, dayKey, day),
          onMouseUp: this._onDayMouseUp.bind(this, dayKey),
          onMouseOver: this._onDayMouseOver.bind(this, dayKey),
          onMouseOut: this._onDayMouseOut.bind(this, dayKey),
          onTouchStart: this._onDayTouchStart.bind(this, dayKey, day),
          onTouchEnd: this._onDayTouchEnd.bind(this, dayKey),
          onFocus: this._onDayFocus.bind(this, dayKey),
          onBlur: this._onDayBlur.bind(this, dayKey),
          'aria-current': ariaCurrent,
          'aria-selected': ariaSelected,
          style: dayStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.dayClassName, this.pseudoStyleIds.dayStyleId) },
        this.props.renderDay ? this.props.renderDay(currentDate) : day
      ) : _react2['default'].createElement(
        'span',
        { key: 'day-' + index,
          style: dayStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.dayClassName, this.pseudoStyleIds.dayStyleId) },
        this.props.showOtherMonthDate ? this.props.renderDay ? this.props.renderDay(currentDate) : day : ''
      );
    }
  }, {
    key: 'render',

    /**
     * Function will render:
     * - main calendar component
     * - call methods to render navBar and week header
     * - get array of weeks in a month and for each day in the week call method to render day
     *
     * It will apply styles sequentially according to following rules:
     * Wrapper:
     * 1. If component is readOnly apply readOnlyWrapperStyle
     * 2. If component is disabled apply disabledWrapperStyle
     *    - If disabled component is hovered apply disabledHoverWrapperStyle
     * 3. If component is not disabled:
     *    - If component is hivered apply hover style
     *    - If component is hovered and active apply hover + active styles
     *    - If component is hovered and focused but not active and preventFocusStyleForTouchAndClick is true apply focusStyles
     * Week:
     * 1. If component is readOnly apply readOnlyWrapperStyle
     * 2. If component is disabled apply disabledWrapperStyle
     */
    value: function render() {
      var _this2 = this;

      var wrapperStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].wrapperStyle, this.props.wrapperStyle);
      var weekStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default'].weekStyle, this.props.weekStyle);
      if (this.props.readOnly) {
        wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].readOnlyWrapperStyle, this.props.readOnlyWrapperStyle);
        weekStyle = (0, _utilsHelpers.extend)(weekStyle, _styleDatePicker2['default'].weekStyle, this.props.weekStyle);
      }
      if (this.props.disabled) {
        wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].disabledWrapperStyle, this.props.disabledWrapperStyle);
        weekStyle = (0, _utilsHelpers.extend)(weekStyle, _styleDatePicker2['default'].weekStyle, this.props.weekStyle);
        if (this.state.isWrapperHovered) {
          wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].disabledHoverWrapperStyle, this.props.disabledHoverWrapperStyle);
        }
      } else {
        if (this.state.isWrapperHovered) {
          wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].hoverWrapperStyle, this.props.hoverWrapperStyle);
        }
        if (this.state.isWrapperActive) {
          wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].activeWrapperStyle, this.props.activeWrapperStyle);
        } else if (this.preventFocusStyleForTouchAndClick && this.state.isWrapperFocused && !(this.state.isPrevMonthFocused || this.state.isNextMonthFocused || this.state.focusedDay)) {
          wrapperStyle = (0, _utilsHelpers.extend)(wrapperStyle, _styleDatePicker2['default'].focusWrapperStyle, this.props.focusWrapperStyle);
        }
      }

      var weekArray = (0, _utilsDateHelpers.getWeekArrayForMonth)(this.state.month, this.state.year, this.state.localeData.firstDay);
      var tabIndex = !this.props.disabled ? this.props.tabIndex : false;

      return _react2['default'].createElement(
        'div',
        { tabIndex: tabIndex,
          onFocus: this._onWrapperFocus.bind(this),
          onBlur: this._onWrapperBlur.bind(this),
          onKeyDown: this._onWrapperKeyDown.bind(this),
          onMouseDown: this._onWrapperMouseDown.bind(this),
          onMouseUp: this._onWrapperMouseUp.bind(this),
          onMouseOver: this._onWrapperMouseOver.bind(this),
          onMouseOut: this._onWrapperMouseOut.bind(this),
          onTouchStart: this._onWrapperTouchStart.bind(this),
          onTouchEnd: this._onWrapperTouchEnd.bind(this),
          disabled: this.props.disabled,
          'aria-label': this.props['aria-label'],
          'aria-disabled': this.props.disabled,
          'aria-readonly': this.props.readOnly,
          style: wrapperStyle,
          className: (0, _utilsUnionClassNames2['default'])(this.props.wrapperClassName, this.pseudoStyleIds.wrapperStyleId) },
        this._getNavBar(),
        this._getDaysHeader(),
        _react2['default'].createElement(
          'div',
          null,
          (0, _utilsHelpers.map)(weekArray, function (week, weekIndex) {
            var weekDays = _this2.state.localeData.isRTL ? (0, _utilsHelpers.reverse)(week) : week;
            return _react2['default'].createElement(
              'div',
              { key: 'week-' + weekIndex,
                style: weekStyle,
                className: _this2.props.weekClassName },
              (0, _utilsHelpers.map)(weekDays, function (day, dayIndex) {
                return _this2._getDayFragment(day, dayIndex);
              })
            );
          })
        )
      );
    }
  }, {
    key: '_focusPreviousDay',

    /**
     * Function is called when some day if focused and ArrowLeft is pressed.
     * It will set focus to previous day, if it was first day of the month it will decrease month and set focus to last day of previous month.
     */
    value: function _focusPreviousDay(days) {
      var _this3 = this;

      var currentFocusedDay = new Date(this.state.focusedDay);
      var currentMonth = currentFocusedDay.getMonth();
      currentFocusedDay.setDate(currentFocusedDay.getDate() - days);
      if (currentFocusedDay.getMonth() === currentMonth) {
        _react2['default'].findDOMNode(this.refs['day-' + (currentFocusedDay.getMonth() + 1) + '/' + currentFocusedDay.getDate() + '/' + currentFocusedDay.getFullYear()]).focus();
      } else {
        this._decreaseMonth(function () {
          _react2['default'].findDOMNode(_this3.refs['day-' + (currentFocusedDay.getMonth() + 1) + '/' + currentFocusedDay.getDate() + '/' + currentFocusedDay.getFullYear()]).focus();
        });
      }
    }
  }, {
    key: '_focusNextDay',

    /**
     * Function is called when some day if focused and ArrowRight is pressed.
     * It will set focus to next day, if it was last day of the month it will increase month and set focus to first day of next month.
     */
    value: function _focusNextDay(days) {
      var _this4 = this;

      var currentFocusedDay = new Date(this.state.focusedDay);
      var currentMonth = currentFocusedDay.getMonth();
      currentFocusedDay.setDate(currentFocusedDay.getDate() + days);
      if (currentFocusedDay.getMonth() === currentMonth) {
        _react2['default'].findDOMNode(this.refs['day-' + (currentFocusedDay.getMonth() + 1) + '/' + currentFocusedDay.getDate() + '/' + currentFocusedDay.getFullYear()]).focus();
      } else {
        this._increaseMonth(function () {
          _react2['default'].findDOMNode(_this4.refs['day-' + (currentFocusedDay.getMonth() + 1) + '/' + currentFocusedDay.getDate() + '/' + currentFocusedDay.getFullYear()]).focus();
        });
      }
    }
  }, {
    key: '_onPrevMonthMouseDown',

    /**
     * Callback is called when prevMonth receives mouse down.
     * If component is not disabled it will decrease the month and set active state for prevMonth.
     */
    value: function _onPrevMonthMouseDown(event) {
      if (event.button === 0 && !this.props.disabled) {
        this._decreaseMonth();
        this.setState({
          isPrevMonthActive: true
        });
      }
    }
  }, {
    key: '_onPrevMonthMouseUp',

    /**
     * Callback is called when prevMonth receives mouse up.
     * It will reset active state for prevMonth.
     */
    value: function _onPrevMonthMouseUp(event) {
      if (event.button === 0 && !this.props.disabled) {
        this.setState({
          isPrevMonthActive: false
        });
      }
    }
  }, {
    key: '_onPrevMonthTouchStart',

    /**
     * Callback is called when prevMonth receives touch start.
     * If component is not disabled it will decrease the month and set active state for prevMonth.
     */
    value: function _onPrevMonthTouchStart(event) {
      if (!this.props.disabled && event.touches.length === 1) {
        this._decreaseMonth();
        this.setState({
          isPrevMonthActive: true
        });
      }
    }
  }, {
    key: '_onPrevMonthTouchEnd',

    /**
     * Callback is called when prevMonth receives touch end.
     * It will reset active state for prevMonth.
     */
    value: function _onPrevMonthTouchEnd() {
      if (!this.props.disabled) {
        this._decreaseMonth();
        this.setState({
          isPrevMonthActive: false
        });
      }
    }
  }, {
    key: '_onPrevMonthFocus',

    /**
     * Callback is called when prevMonth receives focus.
     * It will set prevMonth to focused, if component is not disabled and prevMonth is not active.
     */
    value: function _onPrevMonthFocus() {
      if (!this.props.disabled && !this.state.isPrevMonthActive) {
        this.setState({
          isPrevMonthFocused: true
        });
      }
    }
  }, {
    key: '_onPrevMonthBlur',

    /**
     * Callback is called when prevMonth receives blur.
     * It will reset prevMonth focused state.
     */
    value: function _onPrevMonthBlur() {
      if (!this.props.disabled) {
        this.setState({
          isPrevMonthFocused: false
        });
      }
    }
  }, {
    key: '_onNextMonthMouseDown',

    /**
     * Callback is called when nextMonth receives mouseDown.
     * If component is not disabled it will increase the month and set active state for nextMonth.
     */
    value: function _onNextMonthMouseDown(event) {
      if (event.button === 0 && !this.props.disabled) {
        this._increaseMonth();
        this.setState({
          isNextMonthActive: true
        });
      }
    }
  }, {
    key: '_onNextMonthMouseUp',

    /**
     * Callback is called when nextMonth receives mouse up.
     * It will reset active state for nextMonth.
     */
    value: function _onNextMonthMouseUp(event) {
      if (event.button === 0 && !this.props.disabled) {
        this.setState({
          isNextMonthActive: false
        });
      }
    }
  }, {
    key: '_onNextMonthTouchStart',

    /**
     * Callback is called when nextMonth receives touch start.
     * If component is not disabled it will increase the month and set active state for nextMonth.
     */
    value: function _onNextMonthTouchStart(event) {
      if (!this.props.disabled && event.touches.length === 1) {
        this._increaseMonth();
        this.setState({
          isNextMonthActive: true
        });
      }
    }
  }, {
    key: '_onNextMonthTouchEnd',

    /**
     * Callback is called when nextMonth receives touch end.
     * It will reset active state for nextMonth.
     */
    value: function _onNextMonthTouchEnd() {
      if (!this.props.disabled) {
        this.setState({
          isNextMonthActive: false
        });
      }
    }
  }, {
    key: '_onNextMonthFocus',

    /**
     * Callback is called when nextMonth receives focus.
     * It will set nextMonth to focused, if component is not disabled and nextMonth is not active.
     */
    value: function _onNextMonthFocus() {
      if (!this.props.disabled && !this.state.isNextMonthActive) {
        this.setState({
          isNextMonthFocused: true
        });
      }
    }
  }, {
    key: '_onNextMonthBlur',

    /**
     * Callback is called when nextMonth receives blur.
     * It will reset nextMonth focused state.
     */
    value: function _onNextMonthBlur() {
      if (!this.props.disabled) {
        this.setState({
          isNextMonthFocused: false
        });
      }
    }
  }, {
    key: '_decreaseMonth',

    /**
     * The function will decrease current month in state and call props.onMonthChange.
     * Function takes closure as argument. Right now its used when user uses keys for navigation,
     * we want to decrease month and focus some of its specific date.
     */
    value: function _decreaseMonth(postStateUpdateFunc) {
      var _this5 = this;

      var newMonth = undefined;
      var newYear = undefined;
      if (this.state.month === 0) {
        newMonth = 11;
        newYear = this.state.year - 1;
      } else {
        newMonth = this.state.month - 1;
        newYear = this.state.year;
      }
      this.setState({
        month: newMonth,
        year: newYear
      }, function () {
        if (postStateUpdateFunc) {
          postStateUpdateFunc.call(_this5);
        }
      });
      if (this.props.onMonthChange) {
        this.props.onMonthChange(newMonth + 1);
      }
    }
  }, {
    key: '_increaseMonth',

    /**
     * The function will increase current month in state and call props.onMonthChange.
     * Function takes closure as argument. Right now its used when user uses keys for navigation,
     * we want to decrease month and focus some of its specific date.
     */
    value: function _increaseMonth(postStateUpdateFunc) {
      var _this6 = this;

      var newMonth = undefined;
      var newYear = undefined;
      if (this.state.month === 11) {
        newMonth = 0;
        newYear = this.state.year + 1;
      } else {
        newMonth = this.state.month + 1;
        newYear = this.state.year;
      }
      this.setState({
        month: newMonth,
        year: newYear
      }, function () {
        if (postStateUpdateFunc) {
          postStateUpdateFunc.call(_this6);
        }
      });
      if (this.props.onMonthChange) {
        this.props.onMonthChange(newMonth + 1);
      }
    }
  }, {
    key: 'resetValue',

    /**
     * Reset the value to undefined.
     *
     * This can be used in case you as developer want to reset the rating manually.
     * This function is not very useful when user uses value/ valueLink,
     * in those cases user can directly update props to undefined and that will be reflected by the component.
     */
    value: function resetValue() {
      this.setState({
        dateValue: undefined
      });
    }
  }], [{
    key: 'updatePseudoClassStyle',

    /**
     * Injects pseudo classes for styles into the DOM.
     */
    value: function updatePseudoClassStyle(pseudoStyleIds, properties, preventFocusStyleForTouchAndClick) {
      var styles = [];
      ['navBar', 'prevMonth', 'nextMonth', 'monthLbl', 'dayLbl', 'weekHeader'].forEach(function (elm) {
        var elmFirstCaps = elm[0].toUpperCase() + elm.substr(1, elm.length);
        styles.push({
          id: pseudoStyleIds[elm + 'StyleId'],
          style: (0, _utilsHelpers.extend)({}, _styleDatePicker2['default']['hover' + elmFirstCaps + 'Style'], properties['hover' + elmFirstCaps + 'Style']),
          pseudoClass: 'hover'
        });
      });
      ['wrapper', 'navBar', 'prevMonth', 'nextMonth', 'monthLbl', 'dayLbl', 'weekHeader', 'day'].forEach(function (elm) {
        var elmFirstCaps = elm[0].toUpperCase() + elm.substr(1, elm.length);
        var focusStyle = undefined;
        if (preventFocusStyleForTouchAndClick && elm !== 'day') {
          focusStyle = { outline: 0 };
        } else {
          focusStyle = (0, _utilsHelpers.extend)({}, _styleDatePicker2['default']['focus' + elmFirstCaps + 'Style'], properties['focus' + elmFirstCaps + 'Style']);
        }
        styles.push({
          id: pseudoStyleIds[elm + 'StyleId'],
          style: focusStyle,
          pseudoClass: 'focus'
        });
      });
      (0, _utilsInjectStyle.injectStyles)(styles);
    }
  }, {
    key: 'displayName',
    value: 'Belle DatePicker',
    enumerable: true
  }, {
    key: 'propTypes',
    value: {
      defaultValue: _react2['default'].PropTypes.instanceOf(Date),
      value: _react2['default'].PropTypes.instanceOf(Date),
      valueLink: _react2['default'].PropTypes.shape({
        value: _react2['default'].PropTypes.instanceOf(Date),
        requestChange: _react2['default'].PropTypes.func.isRequired
      }),
      locale: _react2['default'].PropTypes.string,
      month: _react2['default'].PropTypes.oneOf([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
      year: _react2['default'].PropTypes.number,
      showOtherMonthDate: _react2['default'].PropTypes.bool,
      styleWeekend: _react2['default'].PropTypes.bool,
      renderDay: _react2['default'].PropTypes.func,
      onFocus: _react2['default'].PropTypes.func,
      onBlur: _react2['default'].PropTypes.func,
      onKeyDown: _react2['default'].PropTypes.func,
      onDayFocus: _react2['default'].PropTypes.func,
      onDayBlur: _react2['default'].PropTypes.func,
      onDayKeyDown: _react2['default'].PropTypes.func,
      onDayMouseDown: _react2['default'].PropTypes.func,
      onDayMouseUp: _react2['default'].PropTypes.func,
      onDayTouchStart: _react2['default'].PropTypes.func,
      onDayTouchEnd: _react2['default'].PropTypes.func,
      onUpdate: _react2['default'].PropTypes.func,
      onMonthChange: _react2['default'].PropTypes.func,
      tabIndex: _react2['default'].PropTypes.number,
      'aria-label': _react2['default'].PropTypes.string,
      disabled: _react2['default'].PropTypes.bool,
      readOnly: _react2['default'].PropTypes.bool,
      'preventFocusStyleForTouchAndClick': _react2['default'].PropTypes.bool,
      // ClassNames
      wrapperClassName: _react2['default'].PropTypes.string,
      navBarClassName: _react2['default'].PropTypes.string,
      prevMonthClassName: _react2['default'].PropTypes.string,
      nextMonthClassName: _react2['default'].PropTypes.string,
      monthLblClassName: _react2['default'].PropTypes.string,
      dayLblClassName: _react2['default'].PropTypes.string,
      weekClassName: _react2['default'].PropTypes.string,
      dayClassName: _react2['default'].PropTypes.string,
      // wrapper styles
      wrapperStyle: _react2['default'].PropTypes.object,
      disabledWrapperStyle: _react2['default'].PropTypes.object,
      readOnlyWrapperStyle: _react2['default'].PropTypes.object,
      hoverWrapperStyle: _react2['default'].PropTypes.object,
      activeWrapperStyle: _react2['default'].PropTypes.object,
      focusWrapperStyle: _react2['default'].PropTypes.object,
      disabledHoverWrapperStyle: _react2['default'].PropTypes.object,
      // navbar styles
      navBarStyle: _react2['default'].PropTypes.object,
      disabledNavBarStyle: _react2['default'].PropTypes.object,
      readOnlyNavBarStyle: _react2['default'].PropTypes.object,
      hoverNavBarStyle: _react2['default'].PropTypes.object,
      // prevMonth styles
      prevMonthStyle: _react2['default'].PropTypes.object,
      disabledPrevMonthStyle: _react2['default'].PropTypes.object,
      readOnlyPrevMonthStyle: _react2['default'].PropTypes.object,
      hoverPrevMonthStyle: _react2['default'].PropTypes.object,
      activePrevMonthStyle: _react2['default'].PropTypes.object,
      focusPrevMonthStyle: _react2['default'].PropTypes.object,
      // nextMonth styles
      nextMonthStyle: _react2['default'].PropTypes.object,
      disabledNextMonthStyle: _react2['default'].PropTypes.object,
      readOnlyNextMonthStyle: _react2['default'].PropTypes.object,
      hoverNextMonthStyle: _react2['default'].PropTypes.object,
      activeNextMonthStyle: _react2['default'].PropTypes.object,
      focusNextMonthStyle: _react2['default'].PropTypes.object,
      // monthlbl styles
      monthLblStyle: _react2['default'].PropTypes.object,
      disabledMonthLblStyle: _react2['default'].PropTypes.object,
      readOnlyMonthLblStyle: _react2['default'].PropTypes.object,
      hoverMonthLblStyle: _react2['default'].PropTypes.object,
      // week header style
      weekHeaderStyle: _react2['default'].PropTypes.object,
      disabledWeekHeaderStyle: _react2['default'].PropTypes.object,
      readOnlyWeekHeaderStyle: _react2['default'].PropTypes.object,
      hoverWeekHeaderStyle: _react2['default'].PropTypes.object,
      // daylbl styles
      dayLblStyle: _react2['default'].PropTypes.object,
      disabledDayLblStyle: _react2['default'].PropTypes.object,
      readOnlyDayLblStyle: _react2['default'].PropTypes.object,
      hoverDayLblStyle: _react2['default'].PropTypes.object,
      weekendLblStyle: _react2['default'].PropTypes.object,
      // week style
      weekStyle: _react2['default'].PropTypes.object,
      disabledWeekStyle: _react2['default'].PropTypes.object,
      readOnlyWeekStyle: _react2['default'].PropTypes.object,
      hoverWeekStyle: _react2['default'].PropTypes.object,
      // day styles
      dayStyle: _react2['default'].PropTypes.object,
      disabledDayStyle: _react2['default'].PropTypes.object,
      readOnlyDayStyle: _react2['default'].PropTypes.object,
      hoverDayStyle: _react2['default'].PropTypes.object,
      activeDayStyle: _react2['default'].PropTypes.object,
      focusDayStyle: _react2['default'].PropTypes.object,
      disabledHoverDayStyle: _react2['default'].PropTypes.object,
      todayStyle: _react2['default'].PropTypes.object,
      selectedDayStyle: _react2['default'].PropTypes.object,
      otherMonthDayStyle: _react2['default'].PropTypes.object,
      weekendStyle: _react2['default'].PropTypes.object
    },
    enumerable: true
  }, {
    key: 'defaultProps',
    value: {
      month: _utilsDateHelpers.CURRENT_MONTH + 1,
      year: _utilsDateHelpers.CURRENT_YEAR,
      tabIndex: 0,
      'aria-label': 'Calendar',
      disabled: false,
      readOnly: false,
      locale: 'en',
      showOtherMonthDate: true,
      styleWeekend: false
    },
    enumerable: true
  }]);

  return DatePicker;
})(_react.Component);

exports['default'] = DatePicker;
module.exports = exports['default'];