'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = reduxForm;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _actions = require('./actions');

var formActions = _interopRequireWildcard(_actions);

var _getDisplayName = require('./getDisplayName');

var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

var _isPristine = require('./isPristine');

var _isPristine2 = _interopRequireDefault(_isPristine);

var _isValid = require('./isValid');

var _isValid2 = _interopRequireDefault(_isValid);

var _bindActionData = require('./bindActionData');

var _bindActionData2 = _interopRequireDefault(_bindActionData);

var _reducer = require('./reducer');

function isReadonly(prop) {
  var writeProps = ['asyncValidate', 'handleBlur', 'handleChange', 'handleFocus', 'handleSubmit', 'onBlur', 'onChange', 'onFocus'];
  return ! ~writeProps.indexOf(prop);
}

function getSubForm(form, formName, formKey) {
  if (form && form[formName]) {
    if (formKey) {
      if (form[formName][formKey]) {
        return form[formName][formKey];
      }
    } else {
      return form[formName];
    }
  }
  return _reducer.initialState;
}

function getValue(passedValue, event) {
  if (passedValue !== undefined || !event) {
    return passedValue;
  }
  if (event.nativeEvent !== undefined && event.nativeEvent.text !== undefined) {
    return event.nativeEvent.text;
  }
  if (event.target === undefined) {
    // is it a value instead of an event?
    return event;
  }
  var _event$target = event.target;
  var type = _event$target.type;
  var value = _event$target.value;
  var checked = _event$target.checked;
  var files = _event$target.files;
  var dataTransfer = event.dataTransfer;

  if (type === 'checkbox') {
    return checked;
  }
  if (type === 'file') {
    return files || dataTransfer && dataTransfer.files;
  }
  return value;
}

function silenceEvents(fn) {
  return function (event) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (event && event.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
      return fn.apply(undefined, args);
    }
    return fn.apply(undefined, [event].concat(args));
  };
}

function isAsyncValid(errors) {
  return !errors || Object.keys(errors).reduce(function (valid, error) {
    return valid && _isValid2['default'](errors[error]);
  }, true);
}

function reduxForm(config) {
  var _extends6 = _extends({
    validate: function validate() {
      return {};
    },
    touchOnBlur: true,
    touchOnChange: false,
    readonly: false,
    asyncValidate: null,
    asyncBlurFields: []
  }, config);

  var formName = _extends6.form;
  var fields = _extends6.fields;
  var syncValidate = _extends6.validate;
  var readonly = _extends6.readonly;
  var touchOnBlur = _extends6.touchOnBlur;
  var touchOnChange = _extends6.touchOnChange;
  var asyncValidate = _extends6.asyncValidate;
  var asyncBlurFields = _extends6.asyncBlurFields;

  if (!fields || !fields.length) {
    throw new Error('No fields passed to redux-form. Must be passed to ' + 'connectReduxForm({fields: ["my", "field", "names"]})');
  }

  var filterProps = function filterProps(props) {
    return readonly ? Object.keys(props).reduce(function (accumulator, prop) {
      var _extends2;

      return isReadonly(prop) ? _extends({}, accumulator, (_extends2 = {}, _extends2[prop] = props[prop], _extends2)) : accumulator;
    }, {}) : props;
  };

  return function (DecoratedComponent) {
    return (function (_Component) {
      _inherits(ReduxForm, _Component);

      function ReduxForm() {
        _classCallCheck(this, ReduxForm);

        _Component.apply(this, arguments);
      }

      ReduxForm.prototype.componentWillMount = function componentWillMount() {
        var _props = this.props;
        var initialValues = _props.initialValues;
        var dispatch = _props.dispatch;
        var formName = _props.formName;
        var formKey = _props.formKey;
        // eslint-disable-line no-shadow
        if (initialValues) {
          var _ref = formKey ? _bindActionData2['default'](formActions, { form: formName, key: formKey }) : _bindActionData2['default'](formActions, { form: formName });

          var initialize = _ref.initialize;

          dispatch(initialize(initialValues));
        }
      };

      ReduxForm.prototype.render = function render() {
        var _this = this;

        // Read props
        var _props2 = this.props;
        var formName = _props2.formName;
        var form = _props2.form;
        var formKey = _props2.formKey;
        var dispatch = _props2.dispatch;

        var passableProps = _objectWithoutProperties(_props2, ['formName', 'form', 'formKey', 'dispatch']);

        // eslint-disable-line no-shadow
        if (!formName) {
          throw new Error('No form name given to redux-form. Must be passed to ' + 'connectReduxForm({form: [form name]}) or as a "formName" prop');
        }
        var subForm = getSubForm(form, formName, formKey);

        // Calculate calculable state
        var allValid = true;
        var allPristine = true;
        var values = fields.reduce(function (accumulator, field) {
          var _extends3;

          return _extends({}, accumulator, (_extends3 = {}, _extends3[field] = subForm[field] ? subForm[field].value : undefined, _extends3));
        }, {});

        // Create actions

        var _ref2 = formKey ? _bindActionData2['default'](formActions, { form: formName, key: formKey }) : _bindActionData2['default'](formActions, { form: formName });

        var blur = _ref2.blur;
        var change = _ref2.change;
        var focus = _ref2.focus;
        var initialize = _ref2.initialize;
        var reset = _ref2.reset;
        var startAsyncValidation = _ref2.startAsyncValidation;
        var startSubmit = _ref2.startSubmit;
        var stopAsyncValidation = _ref2.stopAsyncValidation;
        var stopSubmit = _ref2.stopSubmit;
        var touch = _ref2.touch;
        var untouch = _ref2.untouch;

        function runAsyncValidation() {
          dispatch(startAsyncValidation(formKey));
          var promise = asyncValidate(values, dispatch);
          if (!promise || typeof promise.then !== 'function') {
            throw new Error('asyncValidate function passed to reduxForm must return a promise!');
          }
          return promise.then(function (asyncErrors) {
            dispatch(stopAsyncValidation(asyncErrors));
            return isAsyncValid(asyncErrors);
          }, function (err) {
            dispatch(stopAsyncValidation({}));
            throw new Error('redux-form: Asynchronous validation failed: ' + err);
          });
        }

        var handleBlur = function handleBlur(name, value) {
          return function (event) {
            var fieldValue = getValue(value, event);
            var doBlur = _bindActionData2['default'](blur, { touch: touchOnBlur });
            dispatch(doBlur(name, fieldValue));
            if (asyncValidate && ~asyncBlurFields.indexOf(name)) {
              var _extends4;

              var syncError = syncValidate(_extends({}, values, (_extends4 = {}, _extends4[name] = fieldValue, _extends4)))[name];
              // only dispatch async call if all synchronous client-side validation passes for this field
              if (!syncError) {
                runAsyncValidation();
              }
            }
          };
        };
        var handleFocus = function handleFocus(name) {
          return function () {
            dispatch(focus(name));
          };
        };
        var handleChange = function handleChange(name, value) {
          return function (event) {
            var doChange = _bindActionData2['default'](change, { touch: touchOnChange });
            dispatch(doChange(name, getValue(value, event)));
          };
        };
        var handleSubmit = function handleSubmit(submitOrEvent) {
          var createEventHandler = function createEventHandler(submit) {
            return function (event) {
              if (event && event.preventDefault) {
                event.preventDefault();
                event.stopPropagation();
              }
              var submitWithPromiseCheck = function submitWithPromiseCheck() {
                var result = submit(values);
                if (result && typeof result.then === 'function') {
                  // you're showing real promise, kid!
                  dispatch(startSubmit());
                  return result.then(function (x) {
                    dispatch(stopSubmit());
                    return x;
                  }, function (x) {
                    dispatch(stopSubmit(x));
                    return x;
                  });
                }
              };
              dispatch(touch.apply(undefined, fields));
              if (allValid) {
                if (asyncValidate) {
                  return runAsyncValidation().then(function (asyncValid) {
                    if (allValid && asyncValid) {
                      return submitWithPromiseCheck(values);
                    }
                  });
                }
                return submitWithPromiseCheck(values);
              }
            };
          };
          if (typeof submitOrEvent === 'function') {
            return createEventHandler(submitOrEvent);
          }
          var onSubmit = _this.props.onSubmit;

          if (!onSubmit) {
            throw new Error('You must either pass handleSubmit() an onSubmit function or pass onSubmit as a prop');
          }
          createEventHandler(onSubmit)(submitOrEvent /* is event */);
        };

        // Define fields
        var syncErrors = syncValidate(values);
        var allFields = fields.reduce(function (accumulator, name) {
          var _extends5;

          var field = subForm[name] || {};
          var pristine = _isPristine2['default'](field.value, field.initial);
          var error = syncErrors[name] || field.asyncError || field.submitError;
          var valid = _isValid2['default'](error);
          if (!valid) {
            allValid = false;
          }
          if (!pristine) {
            allPristine = false;
          }
          return _extends({}, accumulator, (_extends5 = {}, _extends5[name] = filterProps({
            active: subForm._active === name,
            checked: typeof field.value === 'boolean' ? field.value : undefined,
            dirty: !pristine,
            error: error,
            handleBlur: handleBlur(name),
            handleChange: handleChange(name),
            handleFocus: handleFocus(name),
            invalid: !valid,
            name: name,
            onBlur: handleBlur(name),
            onChange: handleChange(name),
            onFocus: handleFocus(name),
            pristine: pristine,
            touched: field.touched,
            valid: valid,
            value: field.value,
            visited: field.visited
          }), _extends5));
        }, {});
        var formError = syncErrors._error || subForm._error;
        if (formError) {
          allValid = false;
        }

        // Return decorated component
        return _react2['default'].createElement(DecoratedComponent, _extends({
          // State:
          active: subForm._active,
          asyncValidating: subForm._asyncValidating,
          dirty: !allPristine,
          error: formError,
          fields: allFields,
          formKey: formKey,
          invalid: !allValid,
          pristine: allPristine,
          submitting: subForm._submitting,
          valid: allValid,
          values: values,

          // Actions:
          asyncValidate: silenceEvents(runAsyncValidation),
          handleBlur: silenceEvents(handleBlur),
          handleChange: silenceEvents(handleChange),
          handleFocus: handleFocus,
          handleSubmit: silenceEvents(handleSubmit),
          initializeForm: silenceEvents(function (initialValues) {
            return dispatch(initialize(initialValues));
          }),
          resetForm: silenceEvents(function () {
            return dispatch(reset());
          }),
          touch: silenceEvents(function () {
            return dispatch(touch.apply(undefined, arguments));
          }),
          touchAll: silenceEvents(function () {
            return dispatch(touch.apply(undefined, fields));
          }),
          untouch: silenceEvents(function () {
            return dispatch(untouch.apply(undefined, arguments));
          }),
          untouchAll: silenceEvents(function () {
            return dispatch(untouch.apply(undefined, fields));
          }),

          // Other:
          dispatch: dispatch
        }, passableProps));
      };

      _createClass(ReduxForm, null, [{
        key: 'displayName',
        value: 'ReduxForm(' + _getDisplayName2['default'](DecoratedComponent) + ')',
        enumerable: true
      }, {
        key: 'DecoratedComponent',
        value: DecoratedComponent,
        enumerable: true
      }, {
        key: 'propTypes',
        value: {
          formName: _react.PropTypes.string,
          formKey: _react.PropTypes.string,
          form: _react.PropTypes.object,
          onSubmit: _react.PropTypes.func,
          dispatch: _react.PropTypes.func.isRequired,
          initialValues: _react.PropTypes.object
        },
        enumerable: true
      }, {
        key: 'defaultProps',
        value: {
          formName: formName
        },
        enumerable: true
      }]);

      return ReduxForm;
    })(_react.Component);
  };
}

module.exports = exports['default'];