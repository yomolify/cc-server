{"version":3,"sources":["../source/helpers.js"],"names":[],"mappings":";;;;;;;;;;QAKgB,MAAM,GAAN,MAAM;QA2BN,KAAK,GAAL,KAAK;QAOL,KAAK,GAAL,KAAK;QAML,gBAAgB,GAAhB,gBAAgB;AA5CzB,IAAM,MAAM,GAAG,SAAT,MAAM,CAAG,IAAI;QAAI,OAAO,IAAI,KAAK,WAAW;CAAA,CAAA;;QAA5C,MAAM,GAAN,MAAM;;;;AAIZ,SAAS,MAAM;;;;;;2BACtB;SAD0B,OAAO,UAE1B,EAAE,GACF,IAAI,GAIH,IAAI,GACJ,mBAAmB;;;qCARD,OAAO;AAAP,UAAO;;;AAEhC,MAAM,EAAE,GAAK,OAAO,CAAC,CAAC,CAAC,CAAA;AACvB,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;;AAEvB,MAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EACtB;AACC,OAAM,IAAI,GAAG,OAAO,CAAC,GAAG,EAAE,CAAA;AAC1B,OAAM,mBAAmB,GAAG,MAAM,CAAC,KAAK,QAAO,OAAO,CAAC,CAAA;;iBACzC,mBAAmB,EAAE,IAAI;;;GACvC;;;;;;;AAED,qCAAgB,aAAY,IAAI,CAAC,4GACjC;QADS,GAAG;;AAEX,QAAI,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK,QAAQ,IAAI,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EACpD;AACC,OAAE,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAA;KACpC,MAED;AACC,OAAE,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAA;KACnB;IACD;;;;;;;;;;;;;;;;AAED,SAAO,EAAE,CAAA;EACT;CAAA;;AAEM,SAAS,KAAK,GACrB;AACC,KAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAA;AAC3D,WAAU,CAAC,OAAO,CAAC,EAAE,CAAC,CAAA;AACtB,QAAO,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAA;CACrC;;AAEM,SAAS,KAAK,CAAC,MAAM,EAC5B;AACC,QAAO,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAA;CACxB;;;;AAGM,SAAS,gBAAgB,CAAC,MAAM,EACvC;;;;;;AACC,qCAAgB,aAAY,MAAM,CAAC,iHACnC;OADS,GAAG;;AAEX,OAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EACzB;AACC,QAAM,eAAe,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,UAAS,KAAK,EAAE,OAAO,EACpE;AACC,YAAO,OAAO,CAAC,WAAW,EAAE,CAAA;KAC5B,CAAC,CAAA;;AAEF,QAAI,CAAC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,EACpC;AACC,WAAM,CAAC,eAAe,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAA;KACrC;IACD;GACD;;;;;;;;;;;;;;;;AAED,QAAO,MAAM,CAAA;CACb","file":"helpers.js","sourcesContent":["// // if the variable is defined\nexport const exists = what => typeof what !== 'undefined'\n\n// extends the first object with \n/* istanbul ignore next: some weird transpiled code, not testable */\nexport function extend(...objects)\n{\n\tconst to   = objects[0]\n\tconst from = objects[1]\n\n\tif (objects.length > 2)\n\t{\n\t\tconst last = objects.pop()\n\t\tconst intermediary_result = extend.apply(this, objects)\n\t\treturn extend(intermediary_result, last)\n\t}\n\n\tfor (let key of Object.keys(from))\n\t{\n\t\tif (typeof from[key] === 'object' && exists(to[key]))\n\t\t{\n\t\t\tto[key] = extend(to[key], from[key])\n\t\t}\n\t\telse\n\t\t{\n\t\t\tto[key] = from[key]\n\t\t}\n\t}\n\n\treturn to\n}\n\nexport function merge()\n{\n\tconst parameters = Array.prototype.slice.call(arguments, 0)\n\tparameters.unshift({})\n\treturn extend.apply(this, parameters)\n}\n\nexport function clone(object)\n{\n\treturn merge({}, object)\n}\n\n// creates camelCased aliases for all the keys of an object\nexport function alias_camel_case(object)\n{\n\tfor (let key of Object.keys(object))\n\t{\n\t\tif (key.indexOf('_') >= 0)\n\t\t{\n\t\t\tconst camel_cased_key = key.replace(/_(.)/g, function(match, group_1)\n\t\t\t{\n\t\t\t\treturn group_1.toUpperCase()\n\t\t\t})\n\n\t\t\tif (!exists(object[camel_cased_key]))\n\t\t\t{\n\t\t\t\tobject[camel_cased_key] = object[key]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn object\n}"]}