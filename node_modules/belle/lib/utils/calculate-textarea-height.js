'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = calculateTextareaHeight;

var _exenv = require('exenv');

var hiddenTextarea = undefined;
var computedStyleCache = {};
var hiddenTextareaStyle = '\n  height:0;\n  visibility:hidden;\n  overflow:hidden;\n  position:absolute;\n  z-index:-1000;\n  top:0;\n  right:0\n';

var stylesToCopy = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-transform', 'width', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

/**
 * Returns an object containing the computed style and the combined vertical
 * padding size, combined vertical border size and box-sizing value.
 *
 * This style is returned as string to be applied as attribute of an element.
 */
function calculateStyling(node) {
  var reactId = node.getAttribute('data-reactid');

  // calculate the computed style only once it's not in the cache
  if (!computedStyleCache[reactId]) {
    (function () {
      // In order to work with legacy browsers the second paramter for pseudoClass
      // has to be provided http://caniuse.com/#feat=getcomputedstyle
      var computedStyle = window.getComputedStyle(node, null);

      var boxSizing = computedStyle.getPropertyValue('box-sizing') || computedStyle.getPropertyValue('-moz-box-sizing') || computedStyle.getPropertyValue('-webkit-box-sizing');

      var verticalPaddingSize = 0;
      verticalPaddingSize = parseFloat(computedStyle.getPropertyValue('padding-bottom')) + parseFloat(computedStyle.getPropertyValue('padding-top'));

      var verticalBorderSize = 0;
      verticalBorderSize = parseFloat(computedStyle.getPropertyValue('border-bottom-width')) + parseFloat(computedStyle.getPropertyValue('border-top-width'));

      var sizingStyle = stylesToCopy.map(function (styleName) {
        return styleName + ':' + computedStyle.getPropertyValue(styleName);
      }).join(';');

      // store the style, vertical padding size, vertical border size and
      // boxSizing inside the cache
      computedStyleCache[reactId] = {
        style: sizingStyle,
        verticalPaddingSize: verticalPaddingSize,
        verticalBorderSize: verticalBorderSize,
        boxSizing: boxSizing
      };
    })();
  }

  return computedStyleCache[reactId];
}

/**
 * Returns an object containing height of the textare as if all the content
 * would be visible. The minHeight & maxHeight are in the object as well and are
 * based on minRows & maxRows.
 *
 * In order to improve the performance a hidden textarea is added to the DOM
 * and used for further caluculations. In addition the styling of each textarea
 * is cached to improve performance.
 */

function calculateTextareaHeight(textareaElement, textareaValue) {
  var minRows = arguments[2] === undefined ? null : arguments[2];
  var maxRows = arguments[3] === undefined ? null : arguments[3];
  var minHeight = arguments[4] === undefined ? null : arguments[4];
  var maxHeight = arguments[5] === undefined ? null : arguments[5];

  if (!_exenv.canUseDOM) {
    return 0;
  }

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
    hiddenTextarea.setAttribute('class', 'belle-input-helper');
  }

  var _calculateStyling = calculateStyling(textareaElement);

  var style = _calculateStyling.style;
  var verticalPaddingSize = _calculateStyling.verticalPaddingSize;
  var verticalBorderSize = _calculateStyling.verticalBorderSize;
  var boxSizing = _calculateStyling.boxSizing;

  hiddenTextarea.setAttribute('style', style + ';' + hiddenTextareaStyle);
  // IE will return a height of 0 in case the textare is empty. To prevent
  // reducing the size to 0 we simply use a dummy text.
  hiddenTextarea.value = textareaValue ? textareaValue : '-';

  var calculatedMinHeight = undefined;
  var calculatedMaxHeight = undefined;
  var height = hiddenTextarea.scrollHeight;

  // for a textarea with border-box, the border width has to be added while
  // for content-box it's necessary to subtract the padding
  if (boxSizing === 'border-box') {
    // border-box: content + padding + border
    height = height + verticalBorderSize;
  } else if (boxSizing === 'content-box') {
    // content-box: content
    height = height - verticalPaddingSize;
  }

  if (minRows !== null && minHeight === null || maxRows !== null && maxHeight === null) {
    // measure height of a textarea with a single row
    hiddenTextarea.value = '-';
    var singleRowHeight = hiddenTextarea.scrollHeight - verticalPaddingSize;

    if (minRows !== null && minHeight === null) {
      calculatedMinHeight = singleRowHeight * minRows;
      if (boxSizing === 'border-box') {
        calculatedMinHeight = calculatedMinHeight + verticalPaddingSize + verticalBorderSize;
      }
    }
    if (maxRows !== null && maxHeight === null) {
      calculatedMaxHeight = singleRowHeight * maxRows;
      if (boxSizing === 'border-box') {
        calculatedMaxHeight = calculatedMaxHeight + verticalPaddingSize + verticalBorderSize;
      }
    }
  }

  var finalMinHeight = minHeight || calculatedMinHeight;
  if (finalMinHeight) {
    height = Math.max(finalMinHeight, height);
  }

  var finalMaxHeight = maxHeight || calculatedMaxHeight;
  if (finalMaxHeight) {
    height = Math.min(finalMaxHeight, height);
  }

  return height;
}

module.exports = exports['default'];