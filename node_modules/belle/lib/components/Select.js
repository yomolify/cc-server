'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _utilsHelpers = require('../utils/helpers');

var _exenv = require('exenv');

var _utilsUnionClassNames = require('../utils/union-class-names');

var _utilsUnionClassNames2 = _interopRequireDefault(_utilsUnionClassNames);

var _utilsInjectStyle = require('../utils/inject-style');

var _styleSelect = require('../style/select');

var _styleSelect2 = _interopRequireDefault(_styleSelect);

var _configSelect = require('../config/select');

var _configSelect2 = _interopRequireDefault(_configSelect);

var _utilsIsComponentOfTypeJs = require('../utils/is-component-of-type.js');

var _utilsIsComponentOfTypeJs2 = _interopRequireDefault(_utilsIsComponentOfTypeJs);

// Enable React Touch Events
_react2['default'].initializeTouchEvents && _react2['default'].initializeTouchEvents(true);

/**
 * Returns true if the provided property is a Placeholder component from Belle.
 */
function isPlaceholder(reactElement) {
  return (0, _utilsIsComponentOfTypeJs2['default'])('Belle Placeholder', reactElement);
}

/**
 * Returns true if the provided property is a Option component from Belle.
 */
function isOption(reactElement) {
  return (0, _utilsIsComponentOfTypeJs2['default'])('Belle Option', reactElement);
}

/**
 * Returns true if the provided property is a Separator component from Belle.
 */
function isSeparator(reactElement) {
  return (0, _utilsIsComponentOfTypeJs2['default'])('Belle Separator', reactElement);
}

/**
 * Verifies that the children is an array containing only Options & at maximum
 * one Placeholder.
 */
function validateChildrenAreOptionsAndMaximumOnePlaceholder(props, propName, componentName) {
  var validChildren = (0, _utilsHelpers.filterReactChildren)(props[propName], function (node) {
    return isOption(node) || isSeparator(node) || isPlaceholder(node);
  });
  if (_react2['default'].Children.count(props[propName]) !== _react2['default'].Children.count(validChildren)) {
    return new Error('Invalid children supplied to `' + componentName + '`, expected an Option, Separator or Placeholder component from Belle.');
  }

  var placeholders = (0, _utilsHelpers.filterReactChildren)(props[propName], function (node) {
    return isPlaceholder(node);
  });
  if (_react2['default'].Children.count(placeholders) > 1) {
    return new Error('Invalid children supplied to `' + componentName + '`, expected only one Placeholder component.');
  }
}

/**
 * Update hover style for the speficied styleId.
 *
 * @param styleId {string} - a unique id that exists as class attribute in the DOM
 * @param properties {object} - the components properties optionally containing hoverStyle
 */
function updatePseudoClassStyle(styleId, properties) {
  var hoverStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].hoverStyle, properties.hoverStyle);
  var disabledHoverStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].disabledHoverStyle, properties.disabledHoverStyle);

  var styles = [{
    id: styleId,
    style: hoverStyle,
    pseudoClass: 'hover'
  }, {
    id: styleId,
    style: disabledHoverStyle,
    pseudoClass: 'hover',
    disabled: true
  }];
  (0, _utilsInjectStyle.injectStyles)(styles);
}

/**
 * Returns true in case there one more element in the list.
 */
var hasNext = function hasNext(list, currentIndex) {
  return currentIndex + 2 <= list.length;
};

/**
 * Returns true in case there is one previous element in the list.
 */
var hasPrevious = function hasPrevious(list, currentIndex) {
  return currentIndex - 1 >= 0;
};

/**
 * Returns an object with properties that are relevant for the wrapping div of
 * the selected option.
 */
function sanitizeSelectedOptionWrapperProps(properties) {
  return (0, _utilsHelpers.omit)(properties, ['onClick', 'style', 'className', 'ref', 'shouldPositionOptions', 'positionOptions', 'focusStyle', 'hoverStyle', 'activeStyle', 'wrapperStyle', 'menuStyle', 'caretToOpenStyle', 'caretToCloseStyle', 'disabledCaretToOpenStyle', 'value', 'defaultValue', 'onUpdate', 'valueLink', 'role', 'aria-expanded', 'id', 'onTouchStart', 'onTouchEnd', 'onTouchCancel', 'onMouseDown', 'onMouseUp', 'disabledStyle', 'disabledHoverStyle']);
}

/**
 * Returns an object with properties that are relevant for the wrapping div of
 * the selected option.
 */
function sanitizeWrapperProps(properties) {
  return (0, _utilsHelpers.omit)(properties, ['style', 'ref', 'tabIndex', 'onKeyDown', 'onBlur', 'onFocus']);
}

/**
 * Returns an object with properties that are relevant for the wrapping div of
 * the selected option.
 */
function sanitizeMenuProps(properties) {
  return (0, _utilsHelpers.omit)(properties, ['style', 'ref', 'aria-labelledby', 'role']);
}

/**
 * Returns an object with properties that are relevant for the wrapping div of
 * the selected option.
 */
function sanitizeCaretProps(properties) {
  return (0, _utilsHelpers.omit)(properties, ['style', 'ref']);
}

/**
 * Select component.
 *
 * In its simplest form the select component behaves almost identical to the
 * native HTML select which the exception that it comes with beautiful styles.
 *
 * Example:
 *
 *     <Select defaultValue="rome">
 *       <Option value="vienna">Vienna</Option>
 *       <Option value="rome">Rome</Option>
 *     </Select>
 *
 * For more advanced examples please see:
 * nikgraf.github.io/belle/#/component/select
 *
 * This component was inpired by:
 * - Jet Watson: https://github.com/JedWatson/react-select
 * - Instructure React Team: https://github.com/instructure-react/react-select-box
 */

var Select = (function (_Component) {

  /*
   * Initialize the component based on the provided properties.
   *
   * By default the Select is closed & the focused option in case the user opens
   * it will be the selected option.
   */

  function Select(properties) {
    _classCallCheck(this, Select);

    _get(Object.getPrototypeOf(Select.prototype), 'constructor', this).call(this, properties);

    var selectedValue = undefined;
    var focusedOptionValue = undefined;

    if (properties.children) {
      this.children = (0, _utilsHelpers.flattenReactChildren)(properties.children);
      this.options = (0, _utilsHelpers.filter)(this.children, isOption);
    }

    if ((0, _utilsHelpers.has)(properties, 'valueLink')) {
      selectedValue = properties.valueLink.value;
      focusedOptionValue = selectedValue;
    } else if ((0, _utilsHelpers.has)(properties, 'value')) {
      selectedValue = properties.value;
      focusedOptionValue = selectedValue;
    } else if ((0, _utilsHelpers.has)(properties, 'defaultValue')) {
      selectedValue = properties.defaultValue;
      focusedOptionValue = selectedValue;
    } else if (!(0, _utilsHelpers.isEmpty)(this.children) && !(0, _utilsHelpers.some)(this.children, isPlaceholder)) {
      var firstOption = (0, _utilsHelpers.first)(this.options);
      selectedValue = firstOption ? firstOption.props.value : void 0;
      focusedOptionValue = selectedValue;
    } else if (!(0, _utilsHelpers.isEmpty)(this.children)) {
      var firstOption = (0, _utilsHelpers.first)(this.options);
      focusedOptionValue = firstOption ? firstOption.props.value : void 0;
    }

    this.state = {
      isOpen: false,
      isFocused: false,
      selectedValue: selectedValue,
      focusedOptionValue: focusedOptionValue,
      selectedOptionWrapperProps: sanitizeSelectedOptionWrapperProps(properties),
      wrapperProps: sanitizeWrapperProps(properties.wrapperProps),
      menuProps: sanitizeMenuProps(properties.menuProps),
      caretProps: sanitizeCaretProps(properties.caretProps),
      selectedOptionWrapperId: properties.id ? properties.id : 'belle-select-id-' + (0, _utilsHelpers.uniqueId)(),
      isTouchedToToggle: false
    };
  }

  _inherits(Select, _Component);

  _createClass(Select, [{
    key: 'componentWillMount',

    /**
     * Generates the style-id & inject the focus & hover style.
     *
     * The style-id is based on React's unique DOM node id.
     */
    value: function componentWillMount() {
      var id = this._reactInternalInstance._rootNodeID.replace(/\./g, '-');
      this._styleId = 'style-id' + id;
      updatePseudoClassStyle(this._styleId, this.props);

      if (_exenv.canUseDOM) {
        this.mouseUpOnDocumentCallback = this._onMouseUpOnDocument.bind(this);
        document.addEventListener('mouseup', this.mouseUpOnDocumentCallback);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(properties) {
      if (properties.children) {
        this.children = (0, _utilsHelpers.flattenReactChildren)(properties.children);
        this.options = (0, _utilsHelpers.filter)(this.children, isOption);
      }

      var newState = {
        selectedOptionWrapperProps: sanitizeSelectedOptionWrapperProps(properties),
        wrapperProps: sanitizeWrapperProps(properties.wrapperProps),
        menuProps: sanitizeMenuProps(properties.menuProps),
        caretProps: sanitizeCaretProps(properties.caretProps),
        selectedOptionWrapperId: properties.id ? properties.id : 'belle-select-id-' + (0, _utilsHelpers.uniqueId)()
      };

      if ((0, _utilsHelpers.has)(properties, 'valueLink')) {
        newState.selectedValue = properties.valueLink.value;
        newState.focusedOptionValue = properties.valueLink.value;
      } else if ((0, _utilsHelpers.has)(properties, 'value')) {
        newState.selectedValue = properties.value;
        newState.focusedOptionValue = properties.value;
      }

      this.setState(newState);
      (0, _utilsInjectStyle.removeStyle)(this._styleId);
      updatePseudoClassStyle(this._styleId, properties);
    }
  }, {
    key: 'componentWillUpdate',

    /**
     * In case shouldPositionOptions is active the scrollTop position is stored
     * to be applied later on. The menu is hidden to make sure it is
     * not displayed beofre repositioned.
     */
    value: function componentWillUpdate(nextProperties, nextState) {
      var shouldPositionOptions = (0, _utilsHelpers.has)(nextProperties, 'shouldPositionOptions') ? nextProperties.shouldPositionOptions : _configSelect2['default'].shouldPositionOptions;

      if (shouldPositionOptions) {
        var menuNode = _react2['default'].findDOMNode(this.refs.menu);
        this.cachedMenuScrollTop = menuNode.scrollTop;

        if (!this.state.isOpen && nextState.isOpen) {
          menuNode.style.display = 'none';
        }
      }
    }
  }, {
    key: 'componentDidUpdate',

    /**
     * In case shouldPositionOptions is active when opening the menu it is
     * repositioned & switched to be visible.
     */
    value: function componentDidUpdate(previousProperties, previousState) {
      var shouldPositionOptions = (0, _utilsHelpers.has)(this.props, 'shouldPositionOptions') ? this.props.shouldPositionOptions : _configSelect2['default'].shouldPositionOptions;

      if (shouldPositionOptions && !this.props.disabled) {
        var menuNode = _react2['default'].findDOMNode(this.refs.menu);

        // the menu was just opened
        if (!previousState.isOpen && this.state.isOpen && this.children && this.children.length > 0) {
          var positionOptions = (0, _utilsHelpers.has)(this.props, 'positionOptions') ? this.props.positionOptions : _configSelect2['default'].positionOptions;
          positionOptions(this);
          // restore the old scrollTop position
        } else {
          menuNode.scrollTop = this.cachedMenuScrollTop;
        }

        var separators = (0, _utilsHelpers.filter)(this.children, isSeparator);
        var childrenPresent = !(0, _utilsHelpers.isEmpty)(this.options) || !(0, _utilsHelpers.isEmpty)(separators);
        if (!previousState.isOpen && this.state.isOpen && childrenPresent) {
          var menuStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].menuStyle, this.props.menuStyle);
          menuNode.style.display = menuStyle.display;
        }
      }
    }
  }, {
    key: 'componentWillUnmount',

    /**
     * Remove a component's associated styles whenever it gets removed from the DOM.
     */
    value: function componentWillUnmount() {
      (0, _utilsInjectStyle.removeStyle)(this._styleId);
      if (_exenv.canUseDOM) {
        document.removeEventListener('mouseup', this.mouseUpOnDocumentCallback);
      }
    }
  }, {
    key: '_onTouchStartAtOption',

    /**
     * Update the focusedOption based on Option the user is touching.
     *
     * Unfortunately updating the focusedOption only works in case the menu
     * is not scrollable.
     * If a setState would be triggered during a touch with the intention to
     * scroll the setState would trigger a re-render & prevent the scrolling.
     */
    value: function _onTouchStartAtOption(event) {
      if (event.touches.length === 1) {
        var entry = event.currentTarget.querySelector('[data-belle-value]');
        this._touchStartedAt = entry.getAttribute('data-belle-value');

        // save the scroll position
        var menuNode = _react2['default'].findDOMNode(this.refs.menu);
        if (menuNode.scrollHeight > menuNode.offsetHeight) {
          this._scrollTopPosition = menuNode.scrollTop;
          // Note: don't use setState in here as it would prevent the scrolling
        } else {
          this._scrollTopPosition = 0;
          this.setState({ focusedOptionValue: this._touchStartedAt });
        }
        // reset interaction
        this._scrollActive = false;
      }
    }
  }, {
    key: '_onTouchMoveAtOption',

    /**
     * Identifies if the menu is scrollable.
     */
    value: function _onTouchMoveAtOption() {
      var menuNode = _react2['default'].findDOMNode(this.refs.menu);
      if (menuNode.scrollTop !== this._scrollTopPosition) {
        this._scrollActive = true;
      }
    }
  }, {
    key: '_onTouchEndAtOption',

    /**
     * Triggers a change event after the user touched on an Option.
     */
    value: function _onTouchEndAtOption() {
      if (this._touchStartedAt && !this._scrollActive) {
        var entry = event.currentTarget.querySelector('[data-belle-value]');
        var value = entry.getAttribute('data-belle-value');
        if (this._touchStartedAt === value) {
          event.preventDefault();
          this._triggerChange(value);
        }
      }
      this._touchStartedAt = undefined;
    }
  }, {
    key: '_onTouchCancelAtOption',

    /**
     * Triggers a change event after the user touched on an Option.
     */
    value: function _onTouchCancelAtOption() {
      this._touchStartedAt = undefined;
    }
  }, {
    key: '_onClickAtOption',

    /**
     * Triggers a change event after the user clicked on an Option.
     */
    value: function _onClickAtOption(event) {
      var entry = event.currentTarget.querySelector('[data-belle-value]');
      this._triggerChange(entry.getAttribute('data-belle-value'));
    }
  }, {
    key: '_onBlur',

    /**
     * In order to inform the user which element in the document is active the
     * component keeps track of when it's de-selected and depending on that
     * close the menu.
     */
    value: function _onBlur(event) {
      this.setState({
        isOpen: false,
        isFocused: false
      });

      if (this.props.wrapperProps && this.props.wrapperProps.onBlur) {
        this.props.wrapperProps.onBlur(event);
      }
    }
  }, {
    key: '_onFocus',

    /**
     * In order to inform the user which element in the document is active the
     * component keeps track of when it's de-selected and depending on that
     * close the menu.
     */
    value: function _onFocus(event) {
      this.setState({
        isFocused: true
      });

      if (this.props.wrapperProps && this.props.wrapperProps.onFocus) {
        this.props.wrapperProps.onFocus(event);
      }
    }
  }, {
    key: '_onMouseEnterAtOption',

    /**
     * In order to inform the user which Option is active the component keeps
     * track of when an option is in focus by the user and depending on that
     * provide a visual indicator.
     */
    value: function _onMouseEnterAtOption(event) {
      var entry = event.currentTarget.querySelector('[data-belle-value]');
      this.setState({
        focusedOptionValue: entry.getAttribute('data-belle-value')
      });
    }
  }, {
    key: '_onTouchStartToggleMenu',

    /**
     * Initiate the toggle for the menu.
     */
    value: function _onTouchStartToggleMenu(event) {
      if (event.touches.length === 1) {
        this.setState({ isTouchedToToggle: true, isActive: true });
      } else {
        this.setState({ isTouchedToToggle: false });
      }

      if (this.props.onTouchStart) {
        this.props.onTouchStart(event);
      }
    }
  }, {
    key: '_onTouchEndToggleMenu',

    /**
     * Toggle the menu after a user touched it & resets the pressed state
     * for to toggle.
     */
    value: function _onTouchEndToggleMenu(event) {
      // In case touch events are used preventDefault is applied to avoid
      // triggering the click event which would cause trouble for toggling.
      // In any case calling setState triggers a render. This leads to the fact
      // that the click event won't be triggered anyways. Nik assumes it's due the
      // element won't be in the DOM anymore.
      // This also means the Select's onClick won't be triggered for touchDevices.
      event.preventDefault();

      /* To avoid weird behaviour we check before focusing again - no specific use-case found */
      var wrapperNode = _react2['default'].findDOMNode(this.refs.wrapper);
      if (document.activeElement !== wrapperNode) {
        wrapperNode.focus();
      }

      if (this.state.isTouchedToToggle) {
        if (this.state.isOpen) {
          this.setState({ isOpen: false });
        } else {
          this.setState({ isOpen: true });
        }
      }
      this.setState({ isTouchedToToggle: false, isActive: false });

      if (this.props.onTouchEnd) {
        this.props.onTouchEnd(event);
      }
    }
  }, {
    key: '_onTouchCancelToggleMenu',

    /**
     * Reset the precondition to initialize a toggle of the menu.
     */
    value: function _onTouchCancelToggleMenu(event) {
      this.setState({ isTouchedToToggle: false, isActive: false });

      if (this.props.onTouchCancel) {
        this.props.onTouchCancel(event);
      }
    }
  }, {
    key: '_onMouseDown',

    /**
     * Set isActive to true on mouse-down.
     */
    value: function _onMouseDown(event) {
      this.setState({ isActive: true });

      if (this.props.onMouseDown) {
        this.props.onMouseDown(event);
      }
    }
  }, {
    key: '_onMouseUp',

    /**
     * Set isActive to false on mouse-up.
     */
    value: function _onMouseUp(event) {
      this.setState({ isActive: false });

      if (this.props.onMouseUp) {
        this.props.onMouseUp(event);
      }
    }
  }, {
    key: '_onMouseUpOnDocument',

    /**
     * Set isActive to false on mouse-up.
     */
    value: function _onMouseUpOnDocument() {
      this.setState({ isActive: false });
    }
  }, {
    key: '_onContextMenu',

    /**
     * Set isActive to false on is context menu opens on select's div.
     */
    value: function _onContextMenu() {
      this.setState({ isActive: false });
    }
  }, {
    key: '_onArrowDownKeyDown',

    /**
     * Update focus for the options for an already open menu.
     *
     * The user experience of HTML's native select is good and the goal here is to
     * achieve the same behaviour.
     *
     * - Focus on the first entry in case no options is focused on.
     * - Switch focus to the next option in case one option already has focus.
     */
    value: function _onArrowDownKeyDown() {
      if (this.state.focusedOptionValue) {
        var indexOfFocusedOption = this._getIndexOfFocusedOption();

        if (hasNext(this.options, indexOfFocusedOption)) {
          this.setState({
            focusedOptionValue: this.options[indexOfFocusedOption + 1].props.value
          });
        }
      } else {
        this.setState({
          focusedOptionValue: (0, _utilsHelpers.first)(this.options).props.value
        });
      }
    }
  }, {
    key: '_onArrowUpKeyDown',

    /**
     * Update focus for the options for an already open menu.
     *
     * The user experience of HTML's native select is good and the goal here is to
     * achieve the same behaviour.
     *
     * - Focus on the last entry in case no options is focused on.
     * - Switch focus to the previous option in case one option already has focus.
     */
    value: function _onArrowUpKeyDown() {
      if (this.state.focusedOptionValue) {
        var indexOfFocusedOption = this._getIndexOfFocusedOption();

        if (hasPrevious(this.options, indexOfFocusedOption)) {
          this.setState({
            focusedOptionValue: this.options[indexOfFocusedOption - 1].props.value
          });
        }
      } else {
        this.setState({
          focusedOptionValue: (0, _utilsHelpers.last)(this.options).props.value
        });
      }
    }
  }, {
    key: '_onEnterOrSpaceKeyDown',

    /**
     * After the user pressed the `Enter` or `Space` key for an already open
     * menu the focused option is selected.
     *
     * Same as _onClickAtOption this update the state & dispatches a change event.
     */
    value: function _onEnterOrSpaceKeyDown() {
      this._triggerChange(this.state.focusedOptionValue);
    }
  }, {
    key: '_onKeyDown',

    /**
     * Manages the keyboard events.
     *
     * In case the Select is in focus, but closed ArrowDown, ArrowUp, Enter and
     * Space will result in opening the menu.
     *
     * In case the menu is already open each key press will have
     * different effects already documented in the related methods.
     *
     * Pressing Escape will close the menu.
     */
    value: function _onKeyDown(event) {
      if (!this.props.disabled) {
        if (!(0, _utilsHelpers.isEmpty)(this.options)) {
          if (!this.state.isOpen) {
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === ' ') {
              event.preventDefault();
              this.setState({ isOpen: true });
            }
          } else {
            // Updates the state to set focus on the next option
            // In case no option is active it should jump to the first.
            // In case it is the last it should stop there.
            if (event.key === 'ArrowDown') {
              event.preventDefault();
              this._onArrowDownKeyDown();
            } else if (event.key === 'ArrowUp') {
              event.preventDefault();
              this._onArrowUpKeyDown();
            } else if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              this._onEnterOrSpaceKeyDown();
            }
          }

          if (event.key === 'Escape') {
            event.preventDefault();
            this.setState({ isOpen: false });
          }
        }
      }

      if (this.props.wrapperProps && this.props.wrapperProps.onKeyDown) {
        this.props.wrapperProps.onKeyDown(event);
      }
    }
  }, {
    key: '_onClickToggleMenu',

    /**
     * Toggle the menu after a user clicked on it.
     */
    value: function _onClickToggleMenu(event) {
      if (!this.props.disabled) {
        if (this.state.isOpen) {
          this.setState({ isOpen: false });
        } else {
          this.setState({ isOpen: true });
        }
      }

      if (this.props.onClick) {
        this.props.onClick(event);
      }
    }
  }, {
    key: '_triggerChange',

    /**
     * After an option has been selected the menu gets closed and the
     * selection processed.
     *
     * Depending on the component's properties the value gets updated and the
     * provided change callback for onUpdate or valueLink is called.
     */
    value: function _triggerChange(value) {
      if ((0, _utilsHelpers.has)(this.props, 'valueLink')) {
        this.props.valueLink.requestChange(value);
        this.setState({
          isOpen: false
        });
      } else if ((0, _utilsHelpers.has)(this.props, 'value')) {
        this.setState({
          isOpen: false
        });
      } else {
        this.setState({
          focusedOptionValue: value,
          selectedValue: value,
          isOpen: false
        });
      }
      if (this.props.onUpdate) {
        this.props.onUpdate({ value: value });
      }
    }
  }, {
    key: '_getIndexOfFocusedOption',

    /**
     * Returns the index of the entry with a certain value from the component's
     * children.
     *
     * The index search includes only option components.
     */
    value: function _getIndexOfFocusedOption() {
      var _this = this;

      return (0, _utilsHelpers.findIndex)(this.options, function (element) {
        return element.props.value === _this.state.focusedOptionValue;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var defaultStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].style, this.props.style);
      var hoverStyle = (0, _utilsHelpers.extend)({}, defaultStyle, _styleSelect2['default'].hoverStyle, this.props.hoverStyle);
      var focusStyle = (0, _utilsHelpers.extend)({}, defaultStyle, _styleSelect2['default'].focusStyle, this.props.focusStyle);
      var activeStyle = (0, _utilsHelpers.extend)({}, defaultStyle, _styleSelect2['default'].activeStyle, this.props.activeStyle);
      var disabledStyle = (0, _utilsHelpers.extend)({}, defaultStyle, _styleSelect2['default'].disabledStyle, this.props.disabledStyle);
      var disabledHoverStyle = (0, _utilsHelpers.extend)({}, disabledStyle, _styleSelect2['default'].disabledHoverStyle, this.props.disabledHoverStyle);
      var menuStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].menuStyle, this.props.menuStyle);
      var caretToCloseStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].caretToCloseStyle, this.props.caretToCloseStyle);
      var caretToOpenStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].caretToOpenStyle, this.props.caretToOpenStyle);
      var disabledCaretToOpenStyle = (0, _utilsHelpers.extend)({}, caretToOpenStyle, _styleSelect2['default'].disabledCaretToOpenStyle, this.props.disabledCaretToOpenStyle);
      var wrapperStyle = (0, _utilsHelpers.extend)({}, _styleSelect2['default'].wrapperStyle, this.props.wrapperStyle);

      var selectedOptionOrPlaceholder = undefined;
      if (this.state.selectedValue) {
        var selectedEntry = (0, _utilsHelpers.find)(this.children, function (entry) {
          return entry.props.value === _this2.state.selectedValue;
        });

        if (selectedEntry) {
          selectedOptionOrPlaceholder = _react2['default'].cloneElement(selectedEntry, {
            _isDisplayedAsSelected: true
          });
        }
      } else {
        selectedOptionOrPlaceholder = (0, _utilsHelpers.find)(this.children, isPlaceholder);
      }

      var separators = (0, _utilsHelpers.filter)(this.children, isSeparator);
      var childrenNotPresent = (0, _utilsHelpers.isEmpty)(this.options) && (0, _utilsHelpers.isEmpty)(separators);
      var computedMenuStyle = this.props.disabled || !this.state.isOpen || childrenNotPresent ? { display: 'none' } : menuStyle;
      var hasCustomTabIndex = this.props.wrapperProps && this.props.wrapperProps.tabIndex;
      var tabIndex = hasCustomTabIndex ? this.props.wrapperProps.tabIndex : '0';

      var selectedOptionWrapperStyle = undefined;
      if (this.props.disabled) {
        selectedOptionOrPlaceholder = _react2['default'].cloneElement(selectedOptionOrPlaceholder, {
          _isDisabled: true
        });
        if (this.state.isTouchedToToggle) {
          selectedOptionWrapperStyle = disabledHoverStyle;
        } else {
          selectedOptionWrapperStyle = disabledStyle;
        }
        tabIndex = -1;
      } else {
        if (this.state.isActive) {
          selectedOptionWrapperStyle = activeStyle;
        } else if (this.state.isFocused) {
          selectedOptionWrapperStyle = focusStyle;
        } else if (this.state.isTouchedToToggle) {
          selectedOptionWrapperStyle = hoverStyle;
        } else {
          selectedOptionWrapperStyle = defaultStyle;
        }
      }

      var caretStyle = undefined;
      if (this.props.disabled) {
        caretStyle = disabledCaretToOpenStyle;
      } else if (this.state.isOpen) {
        caretStyle = caretToCloseStyle;
      } else {
        caretStyle = caretToOpenStyle;
      }

      return _react2['default'].createElement(
        'div',
        _extends({ style: wrapperStyle,
          tabIndex: tabIndex,
          onKeyDown: this._onKeyDown.bind(this),
          onBlur: this._onBlur.bind(this),
          onFocus: this._onFocus.bind(this),
          ref: 'wrapper'
        }, this.state.wrapperProps),
        _react2['default'].createElement(
          'div',
          _extends({ onClick: this._onClickToggleMenu.bind(this),
            onTouchStart: this._onTouchStartToggleMenu.bind(this),
            onTouchEnd: this._onTouchEndToggleMenu.bind(this),
            onTouchCancel: this._onTouchCancelToggleMenu.bind(this),
            onContextMenu: this._onContextMenu.bind(this),
            onMouseDown: this._onMouseDown.bind(this),
            onMouseUp: this._onMouseUp.bind(this),
            style: selectedOptionWrapperStyle,
            className: (0, _utilsUnionClassNames2['default'])(this.props.className, this._styleId),
            ref: 'selectedOptionWrapper',
            role: 'button',
            'aria-expanded': this.state.isOpen,
            id: this.state.selectedOptionWrapperId
          }, this.state.selectedOptionWrapperProps),
          selectedOptionOrPlaceholder,
          _react2['default'].createElement('span', _extends({ style: caretStyle
          }, this.state.caretProps))
        ),
        _react2['default'].createElement(
          'ul',
          _extends({ style: computedMenuStyle,
            role: 'listbox',
            'aria-labelledby': this.state.selectedOptionWrapperId,
            ref: 'menu'
          }, this.state.menuProps),
          _react2['default'].Children.map(this.children, function (entry, index) {
            if (isOption(entry)) {
              var isHovered = entry.props.value === _this2.state.focusedOptionValue;
              var option = _react2['default'].cloneElement(entry, {
                _isHovered: isHovered
              });

              return _react2['default'].createElement(
                'li',
                { onClick: _this2._onClickAtOption.bind(_this2),
                  onTouchStart: _this2._onTouchStartAtOption.bind(_this2),
                  onTouchMove: _this2._onTouchMoveAtOption.bind(_this2),
                  onTouchEnd: _this2._onTouchEndAtOption.bind(_this2),
                  onTouchCancel: _this2._onTouchCancelAtOption.bind(_this2),
                  key: index,
                  onMouseEnter: _this2._onMouseEnterAtOption.bind(_this2),
                  role: 'option',
                  'aria-selected': isHovered },
                option
              );
            } else if (isSeparator(entry)) {
              return _react2['default'].createElement(
                'li',
                { key: index,
                  role: 'presentation' },
                entry
              );
            }
          })
        )
      );
    }
  }], [{
    key: 'displayName',
    value: 'Belle Select',
    enumerable: true
  }, {
    key: 'propTypes',
    value: {
      children: validateChildrenAreOptionsAndMaximumOnePlaceholder,
      value: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.instanceOf(Date)]),
      defaultValue: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.string, _react.PropTypes.number]),
      onUpdate: _react.PropTypes.func,
      valueLink: _react.PropTypes.shape({
        value: _react.PropTypes.string.isRequired,
        requestChange: _react.PropTypes.func.isRequired
      }),
      className: _react.PropTypes.string,
      shouldPositionOptions: _react.PropTypes.bool,
      positionOptions: _react.PropTypes.func,
      style: _react.PropTypes.object,
      focusStyle: _react.PropTypes.object,
      hoverStyle: _react.PropTypes.object,
      activeStyle: _react.PropTypes.object,
      wrapperStyle: _react.PropTypes.object,
      menuStyle: _react.PropTypes.object,
      caretToOpenStyle: _react.PropTypes.object,
      caretToCloseStyle: _react.PropTypes.object,
      wrapperProps: _react.PropTypes.object,
      menuProps: _react.PropTypes.object,
      caretProps: _react.PropTypes.object,
      disabled: _react.PropTypes.bool,
      disabledStyle: _react.PropTypes.object,
      disabledHoverStyle: _react.PropTypes.object,
      disabledCaretToOpenStyle: _react.PropTypes.object,
      onClick: _react.PropTypes.func,
      onTouchCancel: _react.PropTypes.func,
      onMouseDown: _react.PropTypes.func,
      onMouseUp: _react.PropTypes.func,
      onTouchEnd: _react.PropTypes.func,
      onTouchStart: _react.PropTypes.func
    },
    enumerable: true
  }, {
    key: 'defaultProps',
    value: {
      disabled: false
    },
    enumerable: true
  }]);

  return Select;
})(_react.Component);

exports['default'] = Select;
module.exports = exports['default'];
// filter out all non-Option Components